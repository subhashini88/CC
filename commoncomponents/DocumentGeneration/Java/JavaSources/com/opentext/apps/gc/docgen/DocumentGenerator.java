/*
  This class has been generated by the Code Generator
 */

package com.opentext.apps.gc.docgen;

import java.io.ByteArrayInputStream;
import java.io.File;
import java.io.FileNotFoundException;
import java.io.FileOutputStream;
import java.io.IOException;
import java.math.BigInteger;
import java.nio.file.Paths;
import java.util.ArrayList;
import java.util.Base64;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Iterator;
import java.util.List;
import java.util.ListIterator;
import java.util.Map;
import java.util.Map.Entry;
import java.util.Set;
import java.util.TreeMap;

import javax.xml.parsers.DocumentBuilder;
import javax.xml.parsers.DocumentBuilderFactory;
import javax.xml.parsers.ParserConfigurationException;

import org.apache.commons.lang3.StringEscapeUtils;
import org.apache.commons.lang3.StringUtils;
import org.apache.poi.poifs.filesystem.OfficeXmlFileException;
import org.apache.poi.xwpf.usermodel.IBody;
import org.apache.poi.xwpf.usermodel.TextAlignment;
import org.apache.poi.xwpf.usermodel.UnderlinePatterns;
import org.apache.poi.xwpf.usermodel.XWPFAbstractNum;
import org.apache.poi.xwpf.usermodel.XWPFDocument;
import org.apache.poi.xwpf.usermodel.XWPFNum;
import org.apache.poi.xwpf.usermodel.XWPFNumbering;
import org.apache.poi.xwpf.usermodel.XWPFParagraph;
import org.apache.poi.xwpf.usermodel.XWPFRun;
import org.apache.poi.xwpf.usermodel.XWPFStyle;
import org.apache.poi.xwpf.usermodel.XWPFTable;
import org.apache.poi.xwpf.usermodel.XWPFTableCell;
import org.apache.poi.xwpf.usermodel.XWPFTableRow;
import org.apache.xmlbeans.XmlCursor;
import org.apache.xmlbeans.impl.schema.DocumentFactory;
import org.openxmlformats.schemas.wordprocessingml.x2006.main.CTAbstractNum;
import org.openxmlformats.schemas.wordprocessingml.x2006.main.CTBr;
import org.openxmlformats.schemas.wordprocessingml.x2006.main.CTColor;
import org.openxmlformats.schemas.wordprocessingml.x2006.main.CTFonts;
import org.openxmlformats.schemas.wordprocessingml.x2006.main.CTHpsMeasure;
import org.openxmlformats.schemas.wordprocessingml.x2006.main.CTInd;
import org.openxmlformats.schemas.wordprocessingml.x2006.main.CTLvl;
import org.openxmlformats.schemas.wordprocessingml.x2006.main.CTNum;
import org.openxmlformats.schemas.wordprocessingml.x2006.main.CTNumFmt;
import org.openxmlformats.schemas.wordprocessingml.x2006.main.CTNumLvl;
import org.openxmlformats.schemas.wordprocessingml.x2006.main.CTR;
import org.openxmlformats.schemas.wordprocessingml.x2006.main.CTRPr;
import org.openxmlformats.schemas.wordprocessingml.x2006.main.CTRow;
import org.openxmlformats.schemas.wordprocessingml.x2006.main.CTShd;
import org.openxmlformats.schemas.wordprocessingml.x2006.main.STJc;
import org.openxmlformats.schemas.wordprocessingml.x2006.main.STNumberFormat;
import org.openxmlformats.schemas.officeDocument.x2006.sharedTypes.STOnOff1;
import org.openxmlformats.schemas.wordprocessingml.x2006.main.STShd;
import org.openxmlformats.schemas.wordprocessingml.x2006.main.impl.STJcImpl;
import org.w3c.dom.CharacterData;
import org.w3c.dom.Element;
import org.w3c.dom.NamedNodeMap;
import org.w3c.dom.NodeList;
import org.xml.sax.InputSource;
import org.xml.sax.SAXException;

import com.cordys.cpc.bsf.busobject.BSF;
import com.cordys.cpc.bsf.busobject.BusObjectConfig;
import com.cordys.cpc.bsf.soap.SOAPRequestObject;
import com.cordys.util.NomUtil;
import com.eibus.util.logger.CordysLogger;
import com.eibus.util.logger.Severity;
import com.eibus.util.system.EIBProperties;
import com.eibus.xml.nom.Document;
import com.eibus.xml.nom.Node;
import com.eibus.xml.nom.internal.NOMDocumentPool;
import com.opentext.apps.gc.docgen.DocGenInput.NumberingInput;
import com.opentext.apps.gc.docgen.Exceptions.DocGenAlertMessages;
import com.opentext.apps.gc.docgen.Exceptions.DocGenApplicationException;




public class DocumentGenerator extends DocumentGeneratorBase
{
	private static final CordysLogger logger = CordysLogger.getCordysLogger(DocumentGenerator.class);

	private static final String ATTRIBUTE_NODE_NAME = "Mapping";
	private static final String DOCUMENT_TYPE = "docx";
	private static final String MULTIOCCURENCE_TOKEN = "REPEAT";
	private static final String MULTIOCCURENCE_ROW_TOKEN = "REPEATROW";
	private static final String ELMTLVL_TOKEN = "LEVEL";
	private static final String RSVD_START_PATTERN = "[$";
	private static final String RSVD_END_PATTERN = "$]";
	private static final String REPEAT_SEPARATOR = "=";
	private static final String NESTED_START = "STARTFROM";
	private static final String NESTED_TEXT = "ITERATEFOR";
	private static final String ATTR_TEXT_START = "{attr:";
	private static final String ATTR_TEXT_END = "}";
	private static final String REPEATABLE_NODE_NAME = "RepeatableElements";


	public DocumentGenerator()
	{
		this((BusObjectConfig)null);
	}

	public DocumentGenerator(BusObjectConfig config)
	{
		super(config);
	}

	public static boolean DeleteDocPreviewFileFormFS(String fileFolder)
	{
		String orgDN = BSF.getOrganization();
		String orgName = orgDN.substring(orgDN.indexOf('=') + 1, orgDN.indexOf(','));
		String basePath = Paths.get(EIBProperties.getInstallDir()).resolve("content" + File.separator + "docgen" + File.separator + orgName + File.separator + fileFolder).toString();
		File fileDir = new File(basePath); 

		if(fileDir.isDirectory() == false) {
			return false;
		}
		File[] listFiles = fileDir.listFiles();
		for(File file : listFiles)
		{
			if(!file.delete()) 
			{ 
				return false; 
			} 
		}
		if(fileDir.delete()) 
		{ 

			logger._log("com.opentext.apps.gc.docgen.DocumentGenerator",Severity.INFO,null,"Preview document has been deleted from FS - Successful");
			return true; 
		} 
		else
		{ 
			logger._log("com.opentext.apps.gc.docgen.DocumentGenerator",Severity.INFO,null,"Preview document has not been deleted from FS - Unsuccessful");
			return false; 
		}
	}

	public static String GenerateDocumentWithLayoutId(org.w3c.dom.Element InputXML, String LayoutId, String DocumentName, String UniqueId) throws FileNotFoundException, SAXException, IOException, ParserConfigurationException 
	{
		DocGenInput dgInput = new DocGenInput();
		// Fetch details from layout id
		loadLayoutProperties(LayoutId,dgInput);	
		
		String documentStorageTicket = dgInput.getStorageTicket();
		if ("".equals(documentStorageTicket) ||documentStorageTicket  == null)
		{
			logger._log("com.opentext.apps.gc.docgen.DocumentGenerator", Severity.ERROR, null, DocGenAlertMessages.EMPTY_DOCSTORAGETICKET);
			throw new DocGenApplicationException(DocGenAlertMessages.EMPTY_DOCSTORAGETICKET);
		}
		// Download document to server
		String documentContentStream = downloadLayoutDocument(documentStorageTicket);
		if (documentContentStream == null)
		{
			logger._log("com.opentext.apps.gc.docgen.DocumentGenerator", Severity.ERROR, null, DocGenAlertMessages.EMPTY_DOCCONTENTSTREAM);
			throw new DocGenApplicationException(DocGenAlertMessages.EMPTY_DOCCONTENTSTREAM);
		}
		// Building mapping's map
		//mappingBuilder(InputXML);

		// Document generator
		Element outputLocationElem = docGen(documentContentStream, DocumentName , UniqueId, InputXML, false , dgInput);
		String outputDocumentLocation=(outputLocationElem==null)?"":outputLocationElem.getTextContent();
		if (outputDocumentLocation == null)
		{
			logger._log("com.opentext.apps.gc.docgen.DocumentGenerator", Severity.ERROR, null, DocGenAlertMessages.EMPTY_GENERATEDDOCLOCATION);
			throw new DocGenApplicationException(DocGenAlertMessages.EMPTY_GENERATEDDOCLOCATION);
		}
		return outputDocumentLocation;
	}
	public static void loadLayoutProperties(String LAYOUT_ID, DocGenInput dgInput) 
	{
		Document layoutDocument = null;
		int idDocLayout = 0, response = 0, node_DocLayout = 0;
		NOMDocumentPool nomDocPool = NOMDocumentPool.getInstance();
		layoutDocument = nomDocPool.lendDocument();
		try 
		{
			idDocLayout = layoutDocument.createElement("DocLayout-id");
			Node.createTextElement("Id", LAYOUT_ID, idDocLayout);
			SOAPRequestObject readDocLayoutResponse = new SOAPRequestObject("http://schemas/OpenTextDocumentGeneration/DocLayout/operations", "ReadDocLayout ", null, null);
			readDocLayoutResponse.addParameterAsXml(idDocLayout);
			response = readDocLayoutResponse.sendAndWait();
			node_DocLayout = DocGenUtil.getNode(".//DocLayout", response);
			//String docLayoutName = Node.getDataWithDefault(DocGenUtil.getNode(".//Name", node_DocLayout), null);
			dgInput.setStartPattern(Node.getDataWithDefault(DocGenUtil.getNode(".//PatternStart", node_DocLayout), ""));
			dgInput.setEndPattern(Node.getDataWithDefault(DocGenUtil.getNode(".//PatternEnd", node_DocLayout), ""));
			dgInput.setStorageTicket(Node.getDataWithDefault(DocGenUtil.getNode(".//File/StorageTicket", node_DocLayout), ""));
			dgInput.setSampleInputItemId(Node.getDataWithDefault(DocGenUtil.getNode(".//VerificationInput/ValidationInput-id/ItemId", node_DocLayout), ""));				
		} 
		catch (Exception e) 
		{
			logger._log("com.opentext.apps.gc.docgen.DocumentGenerator", Severity.ERROR, e, "Error while executing ReadDocLayout Webservice for the layout ID : "+LAYOUT_ID);
			throw new DocGenApplicationException(DocGenAlertMessages.WEBSERVICE_FAILURE_READ_DOC_LAYOUT);
		} 
		finally 
		{
			DocGenUtil.cleanAll(node_DocLayout, response, idDocLayout);
			nomDocPool.returnDocument(layoutDocument);
			layoutDocument = null;
		}
	}
	public static String downloadLayoutDocument(String FILE_STORAGE_TICKET) 
	{

		int documentURLNode = 0, fetchSettingNode = 0, getDocumentLayoutResponse = 0;
		String documentURL = null;
		Map<String, String> storageMap = null;

		if (null != FILE_STORAGE_TICKET && FILE_STORAGE_TICKET.length() > 0) 
		{
			try 
			{
				storageMap = DocGenUtil.convertJsonToHashMap(FILE_STORAGE_TICKET);
				if (storageMap.size() == 0) 
				{
					return null;
				}
				documentURL = storageMap.get("documentURL");
				//String tempDocName = storageMap.get("documentName");
				//DOCUMENT_NAME = tempDocName.split(".")[0];
				String documentURLInput = "<DocumentURL fetchContent=\"true\">" + documentURL + "</DocumentURL>";
				String fetchSetting = "<FetchSetting>inline</FetchSetting>";
				documentURLNode = DocGenUtil.parseXML(documentURLInput);
				fetchSettingNode = DocGenUtil.parseXML(fetchSetting);
				SOAPRequestObject getDocumentLayoutRequest = new SOAPRequestObject("http://schemas.cordys.com/documentstore/default/1.0", "GetDocument", null, null);
				getDocumentLayoutRequest.addParameterAsXml(documentURLNode);
				getDocumentLayoutRequest.addParameterAsXml(fetchSettingNode);
				getDocumentLayoutResponse = getDocumentLayoutRequest.sendAndWait();

				return Node.getDataWithDefault(DocGenUtil.getNode(".//DocumentContent", getDocumentLayoutResponse), null);
			}  
			catch (Exception e) 
			{
				logger._log("com.opentext.apps.gc.docgen.DocumentGenerator", Severity.ERROR, e, "Error while executing GetDocument Webservice for the storage ticket : "+FILE_STORAGE_TICKET);
				throw new DocGenApplicationException(DocGenAlertMessages.WEBSERVICE_FAILURE_GET_DOCUMENT);
			} 
			finally 
			{
				DocGenUtil.cleanAll(documentURLNode, fetchSettingNode, getDocumentLayoutResponse);
			}
		}
		return null;
	}
	public static void mappingBuilder(Element INPUT_XML, DocGenInput dgInput, HashMap<String, org.w3c.dom.Node> tOKEN_MAPPINGS) throws FileNotFoundException, SAXException, IOException, ParserConfigurationException 
	{
		NodeList Attributes = null;		
		String START_PATTERN = dgInput.getStartPattern();
		String END_PATTERN = dgInput.getEndPattern();
		// Get mapping & child nodes
		try 
		{
			Attributes  = INPUT_XML.getElementsByTagName(ATTRIBUTE_NODE_NAME).item(0).getChildNodes();
		} 
		catch(Exception e) 
		{
			logger._log("com.opentext.apps.gc.docgen.DocumentGenerator", Severity.ERROR, e, "The InputXML is not found or not in proper format. The InputXML is : "+INPUT_XML);
			throw new DocGenApplicationException(DocGenAlertMessages.FORMAT_ERROR_INPUTXML);
		}
		for (int i = 0; i < Attributes.getLength(); i++) 
		{		
			if(Attributes.item(i).hasAttributes())
			{
				org.w3c.dom.Node lAttr = Attributes.item(i);
				NamedNodeMap attributesNode = Attributes.item(i).getAttributes();				
				try 
				{
					if(attributesNode.getNamedItem("key") != null && attributesNode.getNamedItem("value") != null) 
					{
						tOKEN_MAPPINGS.put(START_PATTERN + attributesNode.getNamedItem("key").getNodeValue() + END_PATTERN,	lAttr);				
					}
				} 
				catch(Exception e) 
				{
					logger._log("com.opentext.apps.gc.docgen.DocumentGenerator", Severity.ERROR, e, "Exception while updating the token mappings for the Key :"+attributesNode.getNamedItem("key")+" and value :"+attributesNode.getNamedItem("value"));
					throw new DocGenApplicationException(DocGenAlertMessages.UPDATE_ERROR_MAPPING);
				}	
			}
		}
	}

	public static Element docGen(String DOCUMENT_CONTENT_STREAM, String DOCUMENT_NAME, String LAYOUT_ID, Element iInputXML, boolean isValidation, DocGenInput dgInput) throws FileNotFoundException, IOException, SAXException, ParserConfigurationException 
	{
		org.w3c.dom.Document doc = getNewOutputDocument();
		if(doc==null) {
			logger._log("com.opentext.apps.gc.docgen.DocumentGenerator", Severity.WARN, null, "Unable to get the new output document");
			return null;
		}
		Element valResult = (Element) doc.getElementsByTagName("ValidatorResult").item(0);		
		XWPFDocument document = null;
		String relativeOutputDocLocation = null;
		FileOutputStream outputDocLocation = null;		
		try 
		{	
			HashMap<String, org.w3c.dom.Node> TOKEN_MAPPINGS = new HashMap<String, org.w3c.dom.Node>();
			mappingBuilder(iInputXML,dgInput,TOKEN_MAPPINGS);
			// Reading document
			byte[] docContent = Base64.getDecoder().decode(DOCUMENT_CONTENT_STREAM);
			document = new XWPFDocument(new ByteArrayInputStream(docContent));
			String lStartPattern = dgInput.getStartPattern();
			String lEndPattern = dgInput.getEndPattern();
			if(lStartPattern!=null && lEndPattern!=null && !("".equals(lStartPattern)) && !("".equals(lEndPattern)))
			{
				ParseContainingParagraphs(document,iInputXML,valResult,isValidation,dgInput,TOKEN_MAPPINGS);
				ParseContainingTables(document,iInputXML,valResult,isValidation,dgInput,TOKEN_MAPPINGS);
				if(document.getHeaderFooterPolicy()!=null)
				{
					// Parsing header paragraphs
					ParseContainingParagraphs(document.getHeaderFooterPolicy().getDefaultHeader(),iInputXML,valResult,isValidation,dgInput,TOKEN_MAPPINGS);
					ParseContainingParagraphs(document.getHeaderFooterPolicy().getFirstPageHeader(),iInputXML,valResult,isValidation,dgInput,TOKEN_MAPPINGS);
					ParseContainingParagraphs(document.getHeaderFooterPolicy().getEvenPageHeader(),iInputXML,valResult,isValidation,dgInput,TOKEN_MAPPINGS);
					ParseContainingParagraphs(document.getHeaderFooterPolicy().getOddPageHeader(),iInputXML,valResult,isValidation,dgInput,TOKEN_MAPPINGS);
					// Parsing footer paragraphs
					ParseContainingParagraphs(document.getHeaderFooterPolicy().getDefaultFooter(),iInputXML,valResult,isValidation,dgInput,TOKEN_MAPPINGS);
					ParseContainingParagraphs(document.getHeaderFooterPolicy().getFirstPageFooter(),iInputXML,valResult,isValidation,dgInput,TOKEN_MAPPINGS);
					ParseContainingParagraphs(document.getHeaderFooterPolicy().getEvenPageFooter(),iInputXML,valResult,isValidation,dgInput,TOKEN_MAPPINGS);
					ParseContainingParagraphs(document.getHeaderFooterPolicy().getOddPageFooter(),iInputXML,valResult,isValidation,dgInput,TOKEN_MAPPINGS);
					// Parsing header paragraphs
					ParseContainingTables(document.getHeaderFooterPolicy().getDefaultHeader(),iInputXML,valResult,isValidation,dgInput,TOKEN_MAPPINGS);
					ParseContainingTables(document.getHeaderFooterPolicy().getFirstPageHeader(),iInputXML,valResult,isValidation,dgInput,TOKEN_MAPPINGS);
					ParseContainingTables(document.getHeaderFooterPolicy().getEvenPageHeader(),iInputXML,valResult,isValidation,dgInput,TOKEN_MAPPINGS);
					ParseContainingTables(document.getHeaderFooterPolicy().getOddPageHeader(),iInputXML,valResult,isValidation,dgInput,TOKEN_MAPPINGS);
					// Parsing footer tables
					ParseContainingTables(document.getHeaderFooterPolicy().getDefaultFooter(),iInputXML,valResult,isValidation,dgInput,TOKEN_MAPPINGS);
					ParseContainingTables(document.getHeaderFooterPolicy().getFirstPageFooter(),iInputXML,valResult,isValidation,dgInput,TOKEN_MAPPINGS);
					ParseContainingTables(document.getHeaderFooterPolicy().getEvenPageFooter(),iInputXML,valResult,isValidation,dgInput,TOKEN_MAPPINGS);
					ParseContainingTables(document.getHeaderFooterPolicy().getOddPageFooter(),iInputXML,valResult,isValidation,dgInput,TOKEN_MAPPINGS);
				}			
			}

			if(isValidation)
			{
				return valResult;
			}
			relativeOutputDocLocation = buildDownloadReadPath(DOCUMENT_NAME, LAYOUT_ID);
			outputDocLocation = new FileOutputStream(EIBProperties.getInstallDir()+relativeOutputDocLocation);
			document.write(outputDocLocation);
			Element l_outElement = (Element) doc.getElementsByTagName("OutputRelativePath").item(0);
			l_outElement.setTextContent(relativeOutputDocLocation);			
			return l_outElement;
		} 
		catch (Exception e) 
		{
			if(e instanceof DocGenApplicationException)
			{
				throw e;
			}
			else
			{	
				logger._log("com.opentext.apps.gc.docgen.DocumentGenerator", Severity.ERROR, e, DocGenAlertMessages.DOCUMENT_GENERATION_FAILURE);
				throw new DocGenApplicationException(DocGenAlertMessages.DOCUMENT_GENERATION_FAILURE);
			}
		} 
		finally 
		{
			if (outputDocLocation != null) 
			{
				safeClose(outputDocLocation);
			}
			if(document!=null)
			{
				document.close();
			}
		}
	}

	private static void ParseContainingTables(IBody bodyElem, Element iInputXML, Element valResult, boolean isValidation, DocGenInput dgInput, HashMap<String, org.w3c.dom.Node> tOKEN_MAPPINGS) 
	{
		if(bodyElem==null)
		{
			logger._log("com.opentext.apps.gc.docgen.DocumentGenerator",Severity.INFO,null,"Body element in containing tables are empty");
			return;
		}
		String repeatRowText = RSVD_START_PATTERN+MULTIOCCURENCE_ROW_TOKEN+REPEAT_SEPARATOR; 
		for (XWPFTable table : bodyElem.getTables()) 
		{
			List<XWPFTableRow> lrows = table.getRows();
			XWPFTableRow[] lRowsArray = new XWPFTableRow[lrows.size()];
			Iterator<XWPFTableRow> lRowsIterator = lrows.iterator();

			int iterCount = 0;
			while(lRowsIterator.hasNext())
			{
				lRowsArray[iterCount++]=lRowsIterator.next();
			}
			for (int indx=(iterCount-1);indx>=0;indx--) 
			{
				XWPFTableRow lRow= lRowsArray[indx];
				String OccurenceElement = "";			
				Boolean rptFound = false;				
				Boolean firstText = true;
				for (XWPFTableCell cells : lRow.getTableCells()) 
				{
					for (XWPFParagraph cellParagraph : cells.getParagraphs()) 
					{
						String pText = cellParagraph.getText();
						if(pText!=null)
						{							
							if (firstText && cellParagraph.getText().trim().startsWith(repeatRowText) && (pText.indexOf(RSVD_END_PATTERN)>pText.indexOf(repeatRowText)+1)) 
							{								
								OccurenceElement = pText.substring(pText.indexOf(repeatRowText)+repeatRowText.length(),pText.indexOf(RSVD_END_PATTERN));							
								rptFound=true;
								break;
							}
							else 
							{
								firstText = false;
								checkAndReplaceTokensInParagraph(cellParagraph,valResult,isValidation,true,tOKEN_MAPPINGS,dgInput);
							}
						}
					}
					firstText = false;
					if(rptFound)
					{
						break;
					}
				}
				if(rptFound)
				{
					RepeatRelatedRows(table, lRow,indx,OccurenceElement,iInputXML,valResult,isValidation,dgInput);
				}
			}
		}
	}

	private static void checkAndReplaceTokensInParagraph(XWPFParagraph paragraph, Element valResult, boolean isValidation, Boolean logTokens,HashMap<String, org.w3c.dom.Node> tOKEN_MAPPINGS, DocGenInput dgInput) 
	{
		TreeMap<Integer, String> paragraphTokens = new TreeMap<Integer,String>();
		TreeMap<Integer, String> runsTokens = new TreeMap<Integer,String>();
		if (paragraph.getText() != null) 
		{						
			// Token counter in paragraph
			int accumLength = 0;
			Set<String> lContainingKeys = tOKEN_MAPPINGS.keySet();
			paragraphTokens = patternCounter(paragraph.getText(),lContainingKeys,0,dgInput, false);
			// Proceed if atleast 1 token found in paragraph
			if (paragraphTokens.size() >= 1) 
			{
				List<XWPFRun> runsList = paragraph.getRuns();
				if (runsList != null) 
				{
					TreeMap<Integer, ArrayList<String>> parsableRuns = new TreeMap<Integer, ArrayList<String>>();
					for (int indx=0;indx<runsList.size();indx++)
					{
						ArrayList<String> lSplTokens = null; 
						XWPFRun run = runsList.get(indx);
						String text = run.getText(0);
						String l_fullText = run.text();
						if (text != null) 
						{
							// Token counter in runs
							TreeMap<Integer, String> l_foundTokens = patternCounter(text,lContainingKeys,accumLength,dgInput, false);
							runsTokens.putAll(l_foundTokens);										
							// Replacing mapped keys with values
							if(!isValidation)
							{
								for (Entry<Integer, String> entry : l_foundTokens.entrySet()) 
								{								
									String lValueType = getValueByAttributeName(tOKEN_MAPPINGS.get(entry.getValue()),"datatype");									
									if("html".equalsIgnoreCase(lValueType))
									{
										if(lSplTokens==null)
										{
											lSplTokens = new ArrayList<String>();
										}
										lSplTokens.add(entry.getValue());
									}									
									else
									{
										String l_replacingText=getReplaceableText(text,tOKEN_MAPPINGS.get(entry.getValue()),entry.getValue());
										if(l_replacingText!=null && l_replacingText.length()>0)
										{
											text = text.replace(entry.getValue(), l_replacingText);
											SetTextOfTheRun(run,text, 0);
										}
									}												
								}
							}
							if(lSplTokens!=null)
							{
								parsableRuns.put(indx, lSplTokens);
							}
							logger._log("com.opentext.apps.gc.docgen.DocumentGenerator",Severity.INFO,null,"Replacing of Mappped key with values are done.");
						}
						accumLength+=(l_fullText!=null)?l_fullText.length():0;
					}
					if(!parsableRuns.isEmpty())
					{
						//CreateParsedRunsInParagraph(parsableRuns,paragraph,tOKEN_MAPPINGS,dgInput, null);
					}
				}	
				if(isValidation)
				{									
					mappingMismatchLogger(paragraphTokens, runsTokens, paragraph.getText(), 50,valResult);
				}
				else if(logTokens)
				{
					mappingMismatchLogger(paragraphTokens, runsTokens, paragraph.getText(), 50,null);
				}
			}
			paragraphTokens.clear();
			runsTokens.clear();
		}	
	}


	private static void CreateParsedRunsInParagraph(TreeMap<Integer, ArrayList<String>> iParsableRuns,XWPFParagraph iParagraph, HashMap<String, org.w3c.dom.Node> iTOKEN_MAPPINGS, DocGenInput dgInput, XmlCursor xmlCursor, DocGenParserInput dgnew, CTAbstractNum lCTAbstractNum) 
	{	
		List<XWPFRun> lRunList = iParagraph.getRuns();
		XWPFRun[] pRunArray = new XWPFRun[iParsableRuns.size()];
		Iterator<Integer> lIndxIterator = iParsableRuns.keySet().iterator();
		for(int indx=0;indx<iParsableRuns.size();indx++)
		{
			pRunArray[indx] = lRunList.get(lIndxIterator.next());
		}
		dgInput.setCreatedRunsCount(0);
		dgInput.setIsParaCreated(false);
		ArrayList<Integer> removableRuns = new ArrayList<Integer>();
		int itrIndx=0;
		int lTopPersistedIndex=-1;
		int lCreatedRunsCount = 0;
		Iterator<Entry<Integer, ArrayList<String>>> lItrParser = iParsableRuns.entrySet().iterator();
		//XmlCursor lnewCursor = iParagraph.getCTP().newCursor();
		while(lItrParser.hasNext())
		{
			Entry<Integer, ArrayList<String>> lPlcEntry = lItrParser.next();
			ArrayList<String> lPlaceholders = lPlcEntry.getValue();
			XWPFRun lRun = pRunArray[itrIndx++];			
			Iterator<String> lplcIterator = lPlaceholders.iterator();
			while(lplcIterator.hasNext())
			{
				String lRunText = lRun.text();
				String lplcHolder = lplcIterator.next();
				int lPlcIndex = lRunText.indexOf(lplcHolder);
				if(lPlcIndex>0)
				{
					XWPFRun lNewRun = iParagraph.insertNewRun(lPlcEntry.getKey());
					SetTextOfTheRun(lNewRun,lRunText.substring(0, lPlcIndex));
					lCreatedRunsCount++;
				}
				dgInput.setIsParaCreated(false);
				DocGenParserInput lParserInput = new DocGenParserInput();
				dgInput.getOrCreateNumInput("C", lRun);
				CreateDefaultValuesForParserInput(lRun,lParserInput);
				//CreateDefaultValuesForParserInput(lRun,dgnew);
				org.w3c.dom.Node lDataElement = iTOKEN_MAPPINGS.get(lplcHolder);
				String lnumString = getValueByAttributeName(lDataElement,"numbering");
				Boolean lContinueNumbering = false;
				if("".equalsIgnoreCase(lnumString) || ("CONTINUE".equalsIgnoreCase(lnumString)))
				{
					lContinueNumbering = true;					
					lParserInput.setNumID(dgnew.getNumID());
					lParserInput.setPrevNums(dgnew.getPrevNums());
				}
				if(dgnew != null)
				{
					lParserInput.setNumLevel(dgnew.getNumLevel());
					lParserInput.setAddlLevel(dgnew.getAddlLevel());
					lParserInput.setLvlRoute(dgnew.getLvlRoute());
					lParserInput.setIsNumUsed(dgnew.getIsNumUsed());
					lParserInput.setCurrentLeft(dgnew.getCurrentLeft());
				}
				XWPFParagraph lParagraph = iParagraph;
				Boolean isNewPara = false;
				if(lParagraph.getText().endsWith(lplcHolder) && (lParagraph.getText().contains("\n")))
				{
					lParagraph = createNewIndentedPara(iParagraph, dgnew.getCurrentLeft(), xmlCursor);
					isNewPara= true;
				}
				int lRunCount = CreateRunsByParsing(lParagraph,(isNewPara?0:(lPlcEntry.getKey()+lCreatedRunsCount)),getHTMContentFromDataElement(iTOKEN_MAPPINGS.get(lplcHolder)), lParserInput,true,(lContinueNumbering?lCTAbstractNum:null),dgInput,xmlCursor,(dgnew==null||lContinueNumbering?0:dgnew.getCurrentLeft()),true,false);
				lCreatedRunsCount+= (isNewPara?0:lRunCount);
				if(dgInput.getIsParaCreated() || isNewPara)
				{
					if(lTopPersistedIndex<0)
					{
						lTopPersistedIndex = lPlcEntry.getKey()+lCreatedRunsCount-1;
						if((lPlcIndex+lplcHolder.length())<lRunText.length())
						{
							SetTextOfTheRun(lRun,lRunText.substring(lPlcIndex+lplcHolder.length()));
							lTopPersistedIndex = lPlcEntry.getKey()+lCreatedRunsCount;
						}
						else if((lPlcIndex+lplcHolder.length())==lRunText.length())
						{
							SetTextOfTheRun(lRun,"");
						}
					}
					if(lParagraph.getRuns().size()==0 && isNewPara)
					{
						RemoveParagraphFromDocument(lParagraph);
					}
				}
				else
				{
					if((lPlcIndex+lplcHolder.length())<lRunText.length())
					{
						SetTextOfTheRun(lRun,lRunText.substring(lPlcIndex+lplcHolder.length()));
					}
					else
					{
						removableRuns.add(lPlcEntry.getKey()+lCreatedRunsCount);
					}
				}
				
			}
		}
		//lnewCursor.dispose();
		int rmvRunSize = removableRuns.size();		
		for(int rmvi =rmvRunSize; rmvi>0;rmvi--)
		{
			iParagraph.removeRun(removableRuns.get(rmvi-1));			
		}
		
		int lrunSize = iParagraph.getRuns().size();
		if(lTopPersistedIndex>=0)
		{
			for(int rmvi =lrunSize; rmvi>lTopPersistedIndex;rmvi--)
			{
				iParagraph.removeRun(rmvi);			
			}
		}
	}

	private static void removeNewLineatTheEnd(XWPFParagraph iParagraph) {
		Boolean rmvEndBreak = iParagraph.getText().endsWith("\n");
		while(rmvEndBreak)
		{
			
			XWPFRun lLastRun = iParagraph.getRuns().get(iParagraph.getRuns().size()-1);
			List<CTBr> lBRList = lLastRun.getCTR().getBrList();
			if(lBRList.size()>0)
			{
				lLastRun.getCTR().removeBr(lBRList.size()-1);
				rmvEndBreak = false;
			}
			else if("".equalsIgnoreCase(lLastRun.text().trim()))
			{
				iParagraph.removeRun(iParagraph.getRuns().size()-1);
				rmvEndBreak = iParagraph.getText().endsWith("\n");
			}
			else
			{
				rmvEndBreak = false;
			}
		}
		if(iParagraph.getText()==null || iParagraph.getText().length()<=0)
		{
			RemoveParagraphFromDocument(iParagraph);
		}
	}

	private static void CreateDefaultValuesForParserInput(XWPFRun lRun, DocGenParserInput lParserInput) {
		String lFontFamily=lRun.getFontFamily();
		if(lFontFamily==null || "".equalsIgnoreCase(lFontFamily))
		{
			lFontFamily= "Arial,Helvetica,sans-serif";
		}		
		lParserInput.setFontFamily(lFontFamily);
		int lFontSize = lRun.getFontSize();
		if(lFontSize<=0)
		{
			lFontSize = 10;
		}
		lParserInput.setFontSize(lFontSize);
		
		String lfontColor = lRun.getColor();
		if(lfontColor!=null && !("".equalsIgnoreCase(lfontColor)))
		{
			lParserInput.setColor(lfontColor);
			lParserInput.setDefColour(lfontColor);
		}
		else
		{
			lParserInput.setColor("");
			lParserInput.setDefColour("");
		}
	}

	private static org.w3c.dom.Node getHTMContentFromDataElement(org.w3c.dom.Node iDataNode) 
	{
		String lDataValue = getCharDataFromNode(iDataNode);		
		if("".equalsIgnoreCase(lDataValue))
		{
			return null;
		}		
		DocumentBuilderFactory dbf = DocumentBuilderFactory.newInstance();
		try 
		{
			dbf.setFeature("http://apache.org/xml/features/disallow-doctype-decl", true);
			DocumentBuilder builder = dbf.newDocumentBuilder();
			String lxmlString = "<?xml version=\"1.0\" encoding=\"UTF-8\"?><RTEInput>"+lDataValue.replaceAll("&#8203;","").replaceAll("<br>","\n").replaceAll("&", "&amp;")+"</RTEInput>";
			org.w3c.dom.Document lxmlDoc = builder.parse(new InputSource(new ByteArrayInputStream(lxmlString.getBytes("UTF-8"))));
			return lxmlDoc.getDocumentElement();
		} 
		catch (ParserConfigurationException e) 
		{			
			logger._log("com.opentext.apps.gc.docgen.DocumentGenerator", Severity.ERROR, e, "ParserConfigurationException: Error occured while parsing the html element"+e.getMessage());
			throw new DocGenApplicationException(DocGenAlertMessages.RTE_PARSER_ERROR);
		} 
		catch (SAXException e)
		{			
			logger._log("com.opentext.apps.gc.docgen.DocumentGenerator", Severity.ERROR, e, "SAXException: Error occured while parsing the html element"+e.getMessage());
			throw new DocGenApplicationException(DocGenAlertMessages.RTE_PARSER_ERROR);
		} 
		catch (IOException e) 
		{
			logger._log("com.opentext.apps.gc.docgen.DocumentGenerator", Severity.ERROR, e, "IOException: Error occured while parsing the html element"+e.getMessage());
			throw new DocGenApplicationException(DocGenAlertMessages.RTE_PARSER_ERROR);
		}	
	}

	private static String getCharDataFromNode(org.w3c.dom.Node iDataNode) 
	{
		NodeList list = iDataNode.getChildNodes();
	    String data;
	    for(int index = 0; index < list.getLength(); index++)
	    {
	        if(list.item(index) instanceof CharacterData)
	        {
	            CharacterData child = (CharacterData) list.item(index);
	            data = child.getData();
	            if(data != null && data.trim().length() > 0)
	            {
	                return data;
	            }
	        }
	    }
	    return "";		
	}
	
	private static void SetTextOfTheRun(XWPFRun iSelectedRun,String iRunText,int Pos)
	{
		SetTextOfTheRun(iSelectedRun,iRunText);
	}
	
	private static void SetTextOfTheRun(XWPFRun iSelectedRun,String iRunText)
	{
		if(iSelectedRun !=null &&  iRunText !=null)
		{
			String[] lTextParts = iRunText.split("\n", -2);
			if(lTextParts.length>0)
			{
				iSelectedRun.setText(lTextParts[0],0);
				for(int indx=1;indx<lTextParts.length;indx++)
				{
					iSelectedRun.addBreak();
					iSelectedRun.setText(lTextParts[indx]);
				}
			}
		}
	}

	private static int CreateRunsByParsing(XWPFParagraph iParagraph, int insIndex,	org.w3c.dom.Node iValueNode, DocGenParserInput dgParseInput, boolean iFirstLevelNode,CTAbstractNum cTAbstractNum, DocGenInput dgInput, XmlCursor lnewCursor, int iParaLeft, boolean isRootPara, boolean isULEncountered) 
	{
		if(iValueNode==null)
		{
			return 0;
		}
		int lCount = 0;	
		XWPFParagraph lParagraph= iParagraph;
		NodeList lChildren = iValueNode.getChildNodes();
		boolean lNewParaCreated=false;
		String prevClass = "";
		Boolean isNumUsed =false;
		HashSet<BigInteger> usedIds = new HashSet<BigInteger>();
		for(int num=0;num<lChildren.getLength();num++)
		{			
			org.w3c.dom.Node lChild = lChildren.item(num);
			String lNodeName = lChild.getNodeName();
			if("#comment".equals(lNodeName))
			{
				continue;
			}
			if("#text".equals(lNodeName))
			{	
				if(lChild.getTextContent()==null)
				{
					continue;
				}
				if(iFirstLevelNode && "".equals(lChild.getTextContent().trim()))
				{
					continue;
				}
				
				XWPFRun lCreatedRun = null;
				if(!dgInput.getIsParaCreated())
				{
					lCreatedRun=lParagraph.insertNewRun(insIndex+lCount);
					lCount++;
				}
				else
				{
					lCreatedRun=lParagraph.createRun();
				}
				if(lCreatedRun!=null)
				{	
					String lChildTextContent = lChild.getTextContent();
					if("li".equalsIgnoreCase(iValueNode.getNodeName())) {
						lChildTextContent=lChildTextContent.stripTrailing();
					}
					SetTextOfTheRun(lCreatedRun,StringEscapeUtils.unescapeHtml4(lChildTextContent));
					SetStyleForRun(lCreatedRun,dgParseInput);
				}
			}
			else
			{	
				DocGenParserInput dgnew = new DocGenParserInput(dgParseInput);
				if("ol".equalsIgnoreCase(lNodeName))
				{	
					CTAbstractNum lCTAbstractNum=cTAbstractNum;
					BigInteger lNewId=null;
					XWPFDocument lDoc=lParagraph.getDocument();
					BigInteger numID =null;
					int needNewAbstractNum = 0;
					String lNumClass= getValueByAttributeName(lChild,"class");
					if(isULEncountered || (isRootPara && lCTAbstractNum==null))
					{
						lNumClass = lNumClass.replaceAll("-nested", "-NSDG");
					}
					if(isRootPara && lCTAbstractNum!=null && (lNumClass.indexOf("-nested")<0))
					{
						lNumClass = lNumClass+"-nested";
					}
					if(dgnew.getIsNumUsed() || isNumUsed)
					{
						dgnew.setLvlRoute("");
					}
					if(dgnew.getLvlRoute().length()>0)
					{						
						AddNumberingForLvlOverride(dgnew,lDoc,lNumClass,false,dgInput,iParaLeft,usedIds,"C-");
						dgnew.setBulletInt(dgnew.getBulletInt()+1);
						CreateRunsByParsing(lParagraph,0,lChild,dgnew,true,lCTAbstractNum, dgInput, lnewCursor,iParaLeft, false,isULEncountered);
						dgnew.setIsNumUsed(true);
						isNumUsed = true;
						lNewParaCreated = true;
					}
					else
					{
						if((!isRootPara && !"".equalsIgnoreCase(prevClass)) || (isRootPara && (dgnew.getIsNumUsed() || isNumUsed) && lNumClass.contains("-nested")))
						{
							needNewAbstractNum = 2;
						}
					 	else if(lCTAbstractNum==null || isRootPara)
						{
							needNewAbstractNum = 1;
							dgnew.setNumLevel(-1);
							dgnew.setAddlLevel(dgParseInput.getAddlLevel());
						}						
						else if(!isRootPara)
						{
							needNewAbstractNum = IsDifferenceInLevel(lCTAbstractNum,false,dgnew,lNumClass);
						}
						if(needNewAbstractNum>0)
						{
							lNewId=getNewAbstractNumberingId(lDoc,dgInput);
							DocumentFactory<CTAbstractNum> lNumfact = CTAbstractNum.Factory;
							lCTAbstractNum = lNumfact.newInstance();
							lCTAbstractNum.setAbstractNumId(lNewId);
							if(needNewAbstractNum>1 && cTAbstractNum !=null)
							{
								CloneUptoPreviousLevel(lCTAbstractNum,dgnew,cTAbstractNum,dgnew.getPrevNums());
							}
							numID = lDoc.getNumbering().addNum(lNewId);
							dgnew.setNumID(numID);
							dgInput.addCreatedAbstractIds(lNewId);
						}
						if(needNewAbstractNum<2)
						{
							prevClass = lNumClass;
						}					
						getNewNumberingLevel(dgnew,lDoc,lNumClass,false,lCTAbstractNum,iParaLeft,0,dgInput);
						dgnew.setBulletInt(dgnew.getBulletInt()+1);
						CreateRunsByParsing(lParagraph,0,lChild,dgnew,true,lCTAbstractNum, dgInput, lnewCursor,iParaLeft, false,isULEncountered);
						dgnew.setIsNumUsed(true);
						isNumUsed = true;
						if(needNewAbstractNum>0)
						{
							CreateTentativeLevels(lCTAbstractNum, dgInput);
							XWPFAbstractNum abstractNum = new XWPFAbstractNum(lCTAbstractNum);			
							BigInteger abstractNumID = lDoc.getNumbering().addAbstractNum(abstractNum);						
							lDoc.getNumbering().getNum(numID).getCTNum().getAbstractNumId().setVal(abstractNumID);
							lNewParaCreated = true;
						}
					}
				}
				else if("ul".equalsIgnoreCase(lNodeName))
				{	
					CTAbstractNum lCTAbstractNum=cTAbstractNum;
					BigInteger lNewId=null;
					XWPFDocument lDoc=lParagraph.getDocument();
					BigInteger numID =null;
					int needNewAbstractNum = 0;
					String lNumClass= getValueByAttributeName(lChild,"class");
					if(isULEncountered)
					{
						lNumClass = lNumClass.replace("-nested", "-NSDG");
					}
					if(dgnew.getIsNumUsed() || isNumUsed)
					{
						dgnew.setLvlRoute("");
					}
					if(dgnew.getLvlRoute().length()>0)
					{
						AddNumberingForLvlOverride(dgnew,lDoc,lNumClass,true,dgInput,iParaLeft,usedIds,"C-");
						CreateRunsByParsing(lParagraph,0,lChild,dgnew,true,lCTAbstractNum, dgInput, lnewCursor,iParaLeft, false,true);
						dgnew.setIsNumUsed(true);
						isNumUsed = true;
						lNewParaCreated = true;
					}
					else
					{
						if(lCTAbstractNum==null || isRootPara )
						{
							needNewAbstractNum = 1;	
							dgnew.setNumLevel(-1);
							dgnew.setAddlLevel(dgParseInput.getAddlLevel());
						}
						else if(!"".equalsIgnoreCase(prevClass))
						{
							needNewAbstractNum = 2;
						}
						else
						{
							needNewAbstractNum = IsDifferenceInLevel(lCTAbstractNum,true,dgnew,lNumClass);
						}
						if(needNewAbstractNum>0)
						{
							lNewId=getNewAbstractNumberingId(lDoc,dgInput);
							DocumentFactory<CTAbstractNum> lNumfact = CTAbstractNum.Factory;
							lCTAbstractNum = lNumfact.newInstance();
							lCTAbstractNum.setAbstractNumId(lNewId);
							if(needNewAbstractNum>1 && cTAbstractNum !=null)
							{
								CloneUptoPreviousLevel(lCTAbstractNum,dgnew,cTAbstractNum,"");
							}
							numID = lDoc.getNumbering().addNum(lNewId);
							dgnew.setNumID(numID);
							dgInput.addCreatedAbstractIds(lNewId);					
						}
						if(needNewAbstractNum<2)
						{
							prevClass = "BULLET";
						}
						getNewNumberingLevel(dgnew,lDoc,lNumClass,true,lCTAbstractNum,iParaLeft,0,dgInput);
						CreateRunsByParsing(lParagraph,0,lChild,dgnew,true,lCTAbstractNum, dgInput, lnewCursor,iParaLeft, false,true);
						dgnew.setIsNumUsed(true);
						isNumUsed = true;
						if(needNewAbstractNum>0)
						{
							CreateTentativeLevels(lCTAbstractNum, dgInput);
							XWPFAbstractNum abstractNum = new XWPFAbstractNum(lCTAbstractNum);			
							BigInteger abstractNumID = lDoc.getNumbering().addAbstractNum(abstractNum);						
							lDoc.getNumbering().getNum(numID).getCTNum().getAbstractNumId().setVal(abstractNumID);
							lNewParaCreated = true;
						}
					}
				}
				else if("li".equalsIgnoreCase(lNodeName)  )
				{
					if(dgParseInput.getNumID()!=null)
					{
						dgInput.setIsParaCreated(true);
						XWPFDocument lDoc = lParagraph.getDocument();
						XWPFParagraph lNewParagraph = lDoc.insertNewParagraph(lnewCursor);
						lnewCursor.toNextToken();
						lNewParagraph.getCTP().addNewPPr();
						
						if(lParagraph.getCTP().getPPr()!=null && lParagraph.getCTP().getPPr().getSpacing()!=null)
						{
							lNewParagraph.getCTP().getPPr().addNewSpacing().set(lParagraph.getCTP().getPPr().getSpacing().copy());						
						}
						if(lParagraph.getCTP().getPPr()!=null && lParagraph.getCTP().getPPr().getJc()!=null)
						{
							lNewParagraph.getCTP().getPPr().addNewJc().set(lParagraph.getCTP().getPPr().getJc().copy());
						}
						else
						{
							lNewParagraph.getCTP().getPPr().addNewJc().setVal(STJc.LEFT);
						}
						lNewParagraph.setNumID(dgnew.getNumID());
						lNewParagraph.setVerticalAlignment(TextAlignment.CENTER);
						lNewParagraph.getCTP().getPPr().getNumPr().addNewIlvl().setVal(BigInteger.valueOf(dgnew.getNumLevel()));
					    CreateRunsByParsing(lNewParagraph,0,lChild,dgnew,true,cTAbstractNum, dgInput, lnewCursor,iParaLeft,false,isULEncountered);
					}
					else
					{
						continue;
					}					
				}
				else
				{
					if("p".equalsIgnoreCase(lNodeName))
					{
						if(lNewParaCreated && isRootPara)
						{
							lParagraph =  createNewIndentedPara(iParagraph,dgnew.getCurrentLeft(),lnewCursor);
							dgInput.setIsParaCreated(true);
						}
						else
						{
							lNewParaCreated = true;
						}
					}
					if("b".equalsIgnoreCase(lNodeName)|| "Strong".equalsIgnoreCase(lNodeName))
					{					
						dgnew.setBold();					
					}
					else if("i".equalsIgnoreCase(lNodeName)|| "Itallic".equalsIgnoreCase(lNodeName) || "em".equalsIgnoreCase(lNodeName))
					{					
						dgnew.setItallic();				
					}
					else if("u".equalsIgnoreCase(lNodeName)|| "Underline".equalsIgnoreCase(lNodeName))
					{					
						dgnew.setUnderline();				
					}
					else if("strike".equalsIgnoreCase(lNodeName)|| "strikethrough".equalsIgnoreCase(lNodeName)|| "s".equalsIgnoreCase(lNodeName))
					{					
						dgnew.setStrikeThrough();				
					}
					String lStyleAttr = getValueByAttributeName(lChild,"style");
					if(!"".equalsIgnoreCase(lStyleAttr))
					{
						Map<String, String> lStyleMap = DocGenUtil.convertJsonToMap(lStyleAttr,";");
						String lColor = lStyleMap.get("color");
						if(!"".equalsIgnoreCase(lColor) && lColor!=null && lColor.startsWith("#"))
						{					
							dgnew.setColor(lColor.substring(1));				
						}
						String lFontSize = lStyleMap.get("cc-font-size");
						if(!"".equalsIgnoreCase(lFontSize) && lFontSize!=null && lFontSize.endsWith("px"))
						{					
							dgnew.setFontSize((int) Math.round(0.75*Integer.parseInt(lFontSize.substring(0, lFontSize.length()-2))));			
						}
						String lFontFamily = lStyleMap.get("cc-font-family");
						if(!"".equalsIgnoreCase(lFontFamily) && lFontFamily!=null)
						{					
							dgnew.setFontFamily(lFontFamily);			
						}
						String lBColor = lStyleMap.get("background-color");
						if(!"".equalsIgnoreCase(lBColor) && lBColor!=null && lBColor.startsWith("#"))
						{					
							dgnew.setBackgroundColor(lBColor.substring(1));				
						}
					}
					
					int lNewCount = CreateRunsByParsing(lParagraph,insIndex+lCount,lChild,dgnew,false,cTAbstractNum, dgInput, lnewCursor,iParaLeft,false,isULEncountered);
					if(!dgInput.getIsParaCreated())
					{
						lCount=lCount+lNewCount;
					}
				}
				
			}
		}
		return lCount;
	}



	private static void AddNumberingForLvlOverride(DocGenParserInput dgParseInput, XWPFDocument iDoc, String iNumClass,
			boolean isBullet, DocGenInput dgInput, int iParaLeft, HashSet<BigInteger> usedIds, String prefix) {
		int iCurrentLevel=0;
		if(dgParseInput.getAddlLevel()!=-1)
		{
			iCurrentLevel=dgParseInput.getAddlLevel()+1;
		}
		dgParseInput.setAddlLevel(iCurrentLevel);
		dgParseInput.setNumLevel(dgParseInput.getNumLevel()+1);
				
		String lrouteText = "";		
		
		if(isBullet)
		{
			if(iCurrentLevel>=2)
			{
				lrouteText = prefix+"B-2";
			}
			else
			{
				lrouteText = prefix+"B-"+iCurrentLevel;
			}
		}
		else
		{
			lrouteText = getRouteTextByNumClass(iNumClass,prefix);			
		}
		lrouteText = dgParseInput.getLvlRoute()+lrouteText+";";
		dgParseInput.setLvlRoute(lrouteText);
		BigInteger numVal = dgInput.getOrUpdateNumberingRoute(lrouteText,usedIds);
		if(numVal==null)
		{
			BigInteger abstractNum=getNewAbstractNumberingId(iDoc,dgInput);		
			numVal = iDoc.getNumbering().addNum(abstractNum);
			dgParseInput.setNumID(numVal);
			dgInput.addCreatedAbstractIds(abstractNum);
			dgInput.addCreatedNumID(numVal, lrouteText);
		}
		else
		{
			dgParseInput.setNumID(numVal);
		}
		if(usedIds!=null)
		{
			usedIds.add(numVal);
		}
		
		UpdateCurrentLeftForParser(dgInput,dgParseInput);
	}

	private static String getRouteTextByNumClass(String numClass, String prefix) {
		String lreturntext = prefix;
		if(numClass.contains("-alpha") && numClass.contains("-upper"))
		{
			lreturntext+= "a-u";
		}
		else if(numClass.contains("-alpha"))
		{
			lreturntext+= "a-l";
		}
		else if(numClass.contains("-roman") && numClass.contains("-upper"))
		{
			lreturntext+= "r-u";
		}
		else if(numClass.contains("-roman"))
		{
			lreturntext+= "r-l";
		}
		else
		{
			lreturntext+= "d";
		}
		if(numClass.contains("-nested"))
		{
			lreturntext+= "-n";
		}
		return lreturntext;
	}
	private static int IsDifferenceInLevel(CTAbstractNum oldCTAbstractNum, boolean isBullet, DocGenParserInput dgParseInput, String iNumClass) {
		int lCurrentLevel=0;
		if(dgParseInput.getNumLevel()!=-1)
		{
			lCurrentLevel=dgParseInput.getNumLevel()+1;
		}
		CTLvl lExstLvl = getExistingLevelFromList(oldCTAbstractNum,BigInteger.valueOf(lCurrentLevel));
		if(lExstLvl==null)
		{
			return 0;
		}
		else
		{
			CTNumFmt numFmt = lExstLvl.getNumFmt();
			if(numFmt == null)
			{
				return 2;
			}
			if(isBullet)
			{
				if(!STNumberFormat.BULLET.equals(numFmt.getVal()))
				{
					return 2;
				}
			}
			else
			{
				Boolean isSameFmt = false;
				if(iNumClass.contains("-alpha") && iNumClass.contains("-upper"))
				{
					if(STNumberFormat.UPPER_LETTER.equals(numFmt.getVal()))
					{
						isSameFmt = true;
					}
				}
				else if(iNumClass.contains("-alpha"))
				{
					if(STNumberFormat.LOWER_LETTER.equals(numFmt.getVal()))
					{
						isSameFmt = true;
					}
				}
				else if(iNumClass.contains("-roman") && iNumClass.contains("-upper"))
				{
					if(STNumberFormat.UPPER_ROMAN.equals(numFmt.getVal()))
					{
						isSameFmt = true;
					}
				}
				else if(iNumClass.contains("-roman"))
				{
					if(STNumberFormat.LOWER_ROMAN.equals(numFmt.getVal()))
					{
						isSameFmt = true;
					}
				}
				else
				{
					if(STNumberFormat.DECIMAL.equals(numFmt.getVal()))
					{
						isSameFmt = true;
					}
				}
				if(lCurrentLevel>0 && isSameFmt)
				{
					String lLvlTxt = lExstLvl.getLvlText().getVal();
					if(iNumClass.contains("-nested") )
					{
						isSameFmt=false;
						if(lLvlTxt.split("%").length==(lCurrentLevel+2))
						{
							isSameFmt=true;
						}
					}
					else
					{
						if(lLvlTxt.indexOf("%")!=lLvlTxt.lastIndexOf("%"))
						{
							isSameFmt=false;
						}
					}
				}
				if(!isSameFmt)
				{
					return 2;
				}
			}
		}
		return 0;
	}
	
	private static void CloneUptoPreviousLevel(CTAbstractNum tgtAbstractNum, DocGenParserInput dgParseInput,CTAbstractNum srcAbstractNum, String iPrevNums) 
	{
		int lCurrentLevel=0;
		if(dgParseInput.getNumLevel()!=-1)
		{
			lCurrentLevel=dgParseInput.getNumLevel();
		}
		String[] lPrevNums = null;
		if(iPrevNums!=null && (!"".equalsIgnoreCase(iPrevNums)))
		{
			lPrevNums = iPrevNums.substring(0, iPrevNums.length()-1).split(";"); 
		}
		List<CTLvl> lvlList = srcAbstractNum.getLvlList();
		ListIterator<CTLvl> listItr = lvlList.listIterator();
		while(listItr.hasNext())
		{
			CTLvl lCurrentLvlObj = listItr.next();
			int lvlIntval = lCurrentLvlObj.getIlvl().intValue();
			if(lCurrentLvlObj.getIlvl()!=null && lvlIntval<=lCurrentLevel)
			{
				CTLvl ltgtLevel = tgtAbstractNum.addNewLvl();
				ltgtLevel.set(lCurrentLvlObj.copy());
				if(lPrevNums != null && (lPrevNums.length>lvlIntval) && (lPrevNums[lvlIntval] !=null) && (!"".equalsIgnoreCase(lPrevNums[lvlIntval])))
				{
					int lStartValue = Integer.parseInt(lPrevNums[lvlIntval]);
					ltgtLevel.getStart().setVal(BigInteger.valueOf(lStartValue));
				}
			}
		}
	}

	private static void CreateTentativeLevels(CTAbstractNum lCTAbstractNum, DocGenInput dgInput) {
		List<CTLvl> lvlList = lCTAbstractNum.getLvlList();
		CTLvl lLastLevel = lvlList.get(lvlList.size()-1);
		if(lLastLevel != null && dgInput.getExstAbstractNum()!=null)
		{
			int lExstLvl = lLastLevel.getIlvl().intValue();
			int addedLvls=1;
			for(int i=lExstLvl+1;i<=8;i++)
			{
				CTLvl exstLvl = dgInput.getExstAbstractNum().getLvlArray(i);
				
				if(exstLvl !=null && (((BigInteger) exstLvl.getPPr().getInd().getLeft()).compareTo((BigInteger)lLastLevel.getPPr().getInd().getLeft())>0))
				{
					CTLvl l_copylevel = dgInput.getExstAbstractNum().getLvlArray(lExstLvl+addedLvls);
					if(l_copylevel!=null)
					{
						CTLvl tentCTLevel = lCTAbstractNum.addNewLvl();
						tentCTLevel.set(l_copylevel.copy());
						tentCTLevel.setTentative(STOnOff1.ON);
						tentCTLevel.getPPr().getInd().set(exstLvl.getPPr().getInd().copy());
						addedLvls++;
					}
				}
			}
		}
		else if(lLastLevel != null)
		{
			int lExstLvl = lLastLevel.getIlvl().intValue();
			BigInteger leftSpval = null;
			if(lLastLevel.getPPr()!=null && lLastLevel.getPPr().getInd()!=null && lLastLevel.getPPr().getInd().getLeft()!=null)
			{
				leftSpval = (BigInteger) lLastLevel.getPPr().getInd().getLeft();
			}
			int leftInd = 1;
			String numtxt = "";
			if(lLastLevel.getLvlText() != null)
			{
				numtxt = lLastLevel.getLvlText().getVal();
			}
			String conText = "";
			for(int i=lExstLvl+1;i<=8;i++)
			{
				CTLvl CurrentLevel = lCTAbstractNum.addNewLvl();
				CurrentLevel.set(lLastLevel.copy());
				CurrentLevel.setIlvl(BigInteger.valueOf(i));
				int lnumChars = 1;
				if(numtxt!=null && (!"".equalsIgnoreCase(numtxt)))
				{
					if(numtxt.indexOf("%")>=0 && (numtxt.lastIndexOf("%")!=numtxt.indexOf("%") || (lExstLvl==0)))
					{
						conText = conText+" %"+(i+1)+".";
						CurrentLevel.getLvlText().setVal(numtxt+conText);
						lnumChars = i;
					}
					else if(numtxt.indexOf("%")>=0)
					{
						CurrentLevel.getLvlText().setVal("%"+(i+1)+".");
					}
				}
				if(leftSpval!=null)
				{
					CurrentLevel.getPPr().getInd().setLeft(leftSpval.add(BigInteger.valueOf(leftInd*720)));
					CurrentLevel.getPPr().getInd().setHanging(BigInteger.valueOf(360+lnumChars*170));
					leftInd++;
				}
				CurrentLevel.setTentative(STOnOff1.ON);	
			}
		}
	}

	private static XWPFParagraph createNewIndentedPara(XWPFParagraph iParagraph, int iParaLeft, XmlCursor lnewCursor) 
	{
		XWPFDocument lDoc = iParagraph.getDocument();
		XWPFParagraph lparagraph = lDoc.insertNewParagraph(lnewCursor);
		lnewCursor.toNextToken();
		cloneParagraphPpr(lparagraph, iParagraph);
		int lLeftInd= iParaLeft;
		if(lLeftInd<=0)
		{
			lLeftInd = getParaLeft(iParagraph, lDoc);
		}
		lparagraph.setIndentationLeft(lLeftInd>0?lLeftInd:360);
		if(lparagraph.getCTP().getPPr().isSetInd() && lparagraph.getCTP().getPPr().getInd().isSetHanging())
		{
			lparagraph.getCTP().getPPr().getInd().unsetHanging();
		}
		if(lparagraph.getCTP().getPPr().isSetPStyle())
		{
			lparagraph.getCTP().getPPr().unsetPStyle();
		}
		if(lparagraph.getCTP().getPPr().getNumPr()!=null)
		{
			lparagraph.getCTP().getPPr().unsetNumPr();
		}		
		return lparagraph;
	}
	
	private static BigInteger getNewAbstractNumberingId(XWPFDocument iDoc, DocGenInput dgInput) 
	{
		XWPFNumbering numb= iDoc.getNumbering();
		if(numb==null)
		{
			numb = iDoc.createNumbering();
		}
		BigInteger lNewCTId = BigInteger.valueOf(0);
		while((numb.getAbstractNum(lNewCTId)) != null || (dgInput.hasCreatedabstractId(lNewCTId)))
		{
			lNewCTId=lNewCTId.add(BigInteger.ONE);
		}
		return lNewCTId;
	}
	
	private static void AddOverrideNumsToDocument(XWPFDocument iDoc, BigInteger abstractNumID, DocGenInput dgInput,
			DocGenParserInput dgParser, CTAbstractNum lCTAbstractNum) {
		Iterator<Entry<BigInteger, String>> lEntryItr = dgInput.createdIds.entrySet().iterator();
		while(lEntryItr.hasNext())
		{
			Entry<BigInteger, String> lEntry = lEntryItr.next();
			String lLvlRoute = lEntry.getValue();
			if("Default".equalsIgnoreCase(lLvlRoute) || "New".equalsIgnoreCase(lLvlRoute) || "COMPLETED".equalsIgnoreCase(lLvlRoute))
			{
				continue;
			}
			else if(!lLvlRoute.startsWith(""+dgParser.getNumSysCount()))
			{
				continue;
			}
			else
			{
				DocGenParserInput dgnew = new DocGenParserInput(dgParser);
				CTNum lCTNum = iDoc.getNumbering().getNum(lEntry.getKey()).getCTNum();
				lCTNum.getAbstractNumId().setVal(abstractNumID);
				int lastNestedLvl = -1;
				String[] lLvlClasses = lLvlRoute.substring(0, lLvlRoute.length()-1).split(";");
				for(int indx=0;indx<=8;indx++)
				{
					dgnew.setAddlLevel(dgnew.getAddlLevel()+1);
					String lLvlStr = (indx>=lLvlClasses.length)?lLvlClasses[lLvlClasses.length-1]:lLvlClasses[indx];
					if("".equalsIgnoreCase(lLvlStr))
					{
						continue;
					}
					CTNumLvl lLvlOverride = lCTNum.addNewLvlOverride();
					lLvlOverride.setIlvl(BigInteger.valueOf(indx));
					CTLvl lLvlObj = lLvlOverride.addNewLvl();
					
					if(!lLvlStr.contains("-n"))
					{
						lastNestedLvl = -1;
					}
					else if(lastNestedLvl<0)
					{
						lastNestedLvl = indx;
					}
					
					if(lLvlStr.startsWith("S-"))
					{
						CTLvl lExstLvl = getExistingLevelFromList(lCTAbstractNum,BigInteger.valueOf(indx));
						if(lExstLvl!=null && indx==0)
						{
							lLvlObj.set(lExstLvl.copy());
							if(lLvlObj.isSetTentative())
							{
								lLvlObj.unsetTentative();
							}
							dgnew.setCurrentLeft(((BigInteger) lExstLvl.getPPr().getInd().getLeft()).intValue());
						}
						else
						{
							applyLevelInformation(lLvlObj,indx,lLvlStr,dgnew,lastNestedLvl,dgInput);
						}
					}
					else
					{
						applyLevelInformation(lLvlObj,indx,lLvlStr,dgnew,lastNestedLvl,dgInput);
					}
				}
				lEntry.setValue("COMPLETED");
			}			
		}		
	}
	
private static void applyLevelInformation(CTLvl cTLvl, int iLvl, String lLvlStr, DocGenParserInput dgParseInput, int lastNestedLvl, DocGenInput dgInput) {
		
		if(dgInput.getExstAbstractNum()!=null)
		{
			CTLvl lctExstLvl = dgInput.getExstAbstractNum().getLvlArray(iLvl);
			cTLvl.set(lctExstLvl.copy());
		}
		if(cTLvl.isSetTentative())
		{
			cTLvl.unsetTentative();
		}
		cTLvl.setIlvl(BigInteger.valueOf(iLvl));
		int l_LveltextChars = 0;
		if(!cTLvl.isSetNumFmt())
		{
			cTLvl.addNewNumFmt();
		}
		int l_exstChars=0;
		if( cTLvl.isSetLvlText())
		{
			l_exstChars = StringUtils.countMatches( cTLvl.getLvlText().getVal(), "%");
		}
		else
		{
			cTLvl.addNewLvlText();
		}		
		if(!cTLvl.isSetPPr())
		{
			cTLvl.addNewPPr();
		}
		if(!cTLvl.getPPr().isSetInd())
		{
			cTLvl.getPPr().addNewInd();
		}
		if(!cTLvl.isSetStart())
		{
			cTLvl.addNewStart();
		}
		cTLvl.getStart().setVal(BigInteger.valueOf(1));		
		CTInd ind1=cTLvl.getPPr().getInd();
		
		String fColor = dgParseInput.getDefColour();
		int fSize = dgParseInput.getFontSize();
		String fFamily = dgParseInput.getFontFamily();
		NumberingInput lNumstyle = dgInput.getNumInput(lLvlStr.substring(0, lLvlStr.indexOf("-")));
		if(lNumstyle!=null)
		{
			fColor = ("".equalsIgnoreCase(lNumstyle.getColor()))?fColor:lNumstyle.getColor();
			fFamily = ("".equalsIgnoreCase(lNumstyle.getFontFamily()))?fFamily:lNumstyle.getFontFamily();
			fSize = (lNumstyle.getFontSize()>0)?lNumstyle.getFontSize():fSize;
		}
		if(lLvlStr.indexOf("B")>=0)
		{
			cTLvl.getNumFmt().setVal(STNumberFormat.BULLET);
			if(!cTLvl.isSetRPr())
			{
				cTLvl.addNewRPr();
			}
			CTRPr lvlrpr=cTLvl.getRPr();
			int iCurrentBulletValue =  110+Integer.parseInt(lLvlStr.substring(lLvlStr.lastIndexOf("-")+1));
			
			String lBulletText = String.valueOf((char) 61623);
			String bltText = "Symbol";
			if(lvlrpr.getRFontsList().isEmpty())
			{
				lvlrpr.addNewRFonts();
			}
			CTFonts lRFont = lvlrpr.getRFontsArray(0);
			if(iCurrentBulletValue==111)
			{
				bltText="Courier New";
				lBulletText = "o";
				lRFont.setCs(bltText);
			}
			else if(iCurrentBulletValue>=112)
			{
				bltText="Wingdings";
				lBulletText = String.valueOf((char)61607);				
			}
			cTLvl.getLvlText().setVal(lBulletText);
			lRFont.setAscii(bltText);
			lRFont.setHAnsi(bltText);		
		}
		else
		{
			if( !"".equalsIgnoreCase(fFamily))
			{
				if(!cTLvl.isSetRPr())
				{
					cTLvl.addNewRPr();
				}
				if(cTLvl.getRPr().getRFontsList().isEmpty())
				{
					cTLvl.getRPr().addNewRFonts();
				}
				cTLvl.getRPr().getRFontsArray(0).setAscii(fFamily);
			}
			if(lLvlStr.contains("-a") && lLvlStr.contains("-u"))
			{
				cTLvl.getNumFmt().setVal(STNumberFormat.UPPER_LETTER);
			}
			else if(lLvlStr.contains("-a"))
			{
				cTLvl.getNumFmt().setVal(STNumberFormat.LOWER_LETTER);
			}
			else if(lLvlStr.contains("-r") && lLvlStr.contains("-u"))
			{
				cTLvl.getNumFmt().setVal(STNumberFormat.UPPER_ROMAN);
			}
			else if(lLvlStr.contains("-r"))
			{
				cTLvl.getNumFmt().setVal(STNumberFormat.LOWER_ROMAN);
			}
			else
			{
				cTLvl.getNumFmt().setVal(STNumberFormat.DECIMAL);
			}
			if(lLvlStr.contains("-n"))
			{
				int lvlCns= ((lastNestedLvl-1)<=0)?0:(lastNestedLvl-1);
				String levelText="";
				for(int lvl=lvlCns+1;lvl<=(iLvl+1);lvl++)
				{
					levelText+=" %"+lvl+".";
					l_LveltextChars++;
				}
				cTLvl.getLvlText().setVal(levelText);
			}
			else
			{	
				l_LveltextChars =1;
				if(l_exstChars!=1)
				{
					cTLvl.getLvlText().setVal("%"+(iLvl+1)+".");
				}
			}
		}
		if( !"".equalsIgnoreCase(fColor) )
		{
			if(!cTLvl.isSetRPr())
			{
				cTLvl.addNewRPr();
			}
			if(cTLvl.getRPr().getColorList().isEmpty())
			{
				cTLvl.getRPr().addNewColor();
			}
			cTLvl.getRPr().getColorArray(0).setVal(fColor);
		}
		
		if( fSize>0 )
		{
			if(!cTLvl.isSetRPr())
			{
				cTLvl.addNewRPr();
			}
			if(cTLvl.getRPr().getSzList().isEmpty())
			{
				cTLvl.getRPr().addNewSz();
			}
			cTLvl.getRPr().getSzArray(0).setVal(BigInteger.valueOf(fSize*2));
		}
		if(!cTLvl.isSetLvlJc())
		{
			cTLvl.addNewLvlJc().setVal(STJcImpl.LEFT);
		}
		
		UpdateCurrentLeftForParser(dgInput, dgParseInput);
		ind1.setLeft(BigInteger.valueOf(dgParseInput.getCurrentLeft()));
		
		if(ind1.isSetHanging())
		{
			int lhangVal = ((BigInteger) ind1.getHanging()).intValue();
			if(l_LveltextChars!=l_exstChars)
			{
				lhangVal = Math.round(((lhangVal-180)*l_LveltextChars/l_exstChars))+180;
				ind1.setHanging(BigInteger.valueOf(lhangVal));
			}
		}
		else
		{
			int lhangVal = 360;
			if(dgParseInput.getFontSize()>0)
			{
				lhangVal = (l_LveltextChars*(16*dgParseInput.getFontSize()+10))+190;
			}
			else
			{
				lhangVal = (l_LveltextChars*170)+190; 
			}
			if(l_LveltextChars==3)
			{
				lhangVal = lhangVal+20;
			}
			ind1.setHanging(BigInteger.valueOf(lhangVal));
		}
		
	}

	private static void getNewNumberingLevel(DocGenParserInput dgParseInput, XWPFDocument iDoc,String numClass,Boolean isBullet,CTAbstractNum cTAbstractNum,int ParaLeft, int iExactLeft, DocGenInput dgInput) 
	{
		int iCurrentLevel=0;
		if(dgParseInput.getAddlLevel()!=-1)
		{
			iCurrentLevel=dgParseInput.getAddlLevel()+1;
		}
		dgParseInput.setAddlLevel(iCurrentLevel);
		dgParseInput.setNumLevel(dgParseInput.getNumLevel()+1);
		CTLvl lExstLvl = getExistingLevelFromList(cTAbstractNum,BigInteger.valueOf(dgParseInput.getNumLevel()));
		if(lExstLvl!=null)
		{
			if(isBullet && lExstLvl.getNumFmt().getVal().equals(STNumberFormat.BULLET))
			{
				dgParseInput.setBulletInt(dgParseInput.getBulletInt()+1);
			}
			UpdateCurrentLeftForParser(dgInput, dgParseInput);
			return;
		}
		
		CTLvl cTLvl = cTAbstractNum.addNewLvl();
		if(dgInput.getExstAbstractNum()!=null)
		{
			CTLvl lctExstLvl = dgInput.getExstAbstractNum().getLvlArray(iCurrentLevel);
			cTLvl.set(lctExstLvl.copy());
		}
		cTLvl.setIlvl(BigInteger.valueOf(dgParseInput.getNumLevel()));
		int l_LveltextChars = 1;
		if(!cTLvl.isSetNumFmt())
		{
			cTLvl.addNewNumFmt();
		}
		int l_exstChars=0;
		if( cTLvl.isSetLvlText())
		{
			l_exstChars = StringUtils.countMatches( cTLvl.getLvlText().getVal(), "%");
		}
		else
		{
			cTLvl.addNewLvlText();
		}		
		if(!cTLvl.isSetPPr())
		{
			cTLvl.addNewPPr();
		}
		if(!cTLvl.getPPr().isSetInd())
		{
			cTLvl.getPPr().addNewInd();
		}
		if(!cTLvl.isSetStart())
		{
			cTLvl.addNewStart();
		}
		cTLvl.getStart().setVal(BigInteger.valueOf(1));		
		CTInd ind1=cTLvl.getPPr().getInd();
		
		if(isBullet)
		{
			cTLvl.getNumFmt().setVal(STNumberFormat.BULLET);
			if(!cTLvl.isSetRPr())
			{
				cTLvl.addNewRPr();
			}
			CTRPr lvlrpr=cTLvl.getRPr();
			int iCurrentBulletValue = (dgParseInput.getBulletInt()+1);
			dgParseInput.setBulletInt(iCurrentBulletValue);
			//iCurrentBulletValue = 110+dgParseInput.getNumLevel();
			String lBulletText = String.valueOf((char) 61623);
			String bltText = "Symbol";
			if(lvlrpr.getRFontsList().isEmpty())
			{
				lvlrpr.addNewRFonts();
			}
			if(iCurrentBulletValue==111)
			{
				bltText="Courier New";
				lBulletText = "o";
				lvlrpr.getRFontsArray(0).setCs(bltText);
			}
			else if(iCurrentBulletValue>=112)
			{
				bltText="Wingdings";
				lBulletText = String.valueOf((char)61607);				
			}
			cTLvl.getLvlText().setVal(lBulletText);
			lvlrpr.getRFontsArray(0).setAscii(bltText);
			lvlrpr.getRFontsArray(0).setHAnsi(bltText);
		}
		else
		{
			if( !"".equalsIgnoreCase(dgParseInput.getFontFamily()))
			{
				if(!cTLvl.isSetRPr())
				{
					cTLvl.addNewRPr();
				}
				if(cTLvl.getRPr().getRFontsList().isEmpty())
				{
					cTLvl.getRPr().addNewRFonts();
				}
				cTLvl.getRPr().getRFontsArray(0).setAscii(dgParseInput.getFontFamily());
			}
			if(numClass.contains("-alpha") && numClass.contains("-upper"))
			{
				cTLvl.getNumFmt().setVal(STNumberFormat.UPPER_LETTER);
			}
			else if(numClass.contains("-alpha"))
			{
				cTLvl.getNumFmt().setVal(STNumberFormat.LOWER_LETTER);
			}
			else if(numClass.contains("-roman") && numClass.contains("-upper"))
			{
				cTLvl.getNumFmt().setVal(STNumberFormat.UPPER_ROMAN);
			}
			else if(numClass.contains("-roman"))
			{
				cTLvl.getNumFmt().setVal(STNumberFormat.LOWER_ROMAN);
			}
			else
			{
				cTLvl.getNumFmt().setVal(STNumberFormat.DECIMAL);
			}
			if(numClass.contains("-nested"))
			{
				String levelText="%1.";
				for(int lvl=2;lvl<=(dgParseInput.getNumLevel()+1);lvl++)
				{
					levelText+=" %"+lvl+".";
					l_LveltextChars++;
				}
				cTLvl.getLvlText().setVal(levelText);
			}
			else
			{
				if(l_exstChars==1)
				{
					cTLvl.getLvlText().setVal(cTLvl.getLvlText().getVal().replaceAll(""+(iCurrentLevel+1),""+(dgParseInput.getNumLevel()+1)));
				}
				else
				{
					cTLvl.getLvlText().setVal("%"+(dgParseInput.getNumLevel()+1)+".");
				}				
			}
		}
		
		if( !"".equalsIgnoreCase(dgParseInput.getDefColour()) )
		{
			if(!cTLvl.isSetRPr())
			{
				cTLvl.addNewRPr();
			}
			if(cTLvl.getRPr().getColorList().isEmpty())
			{
				cTLvl.getRPr().addNewColor();
			}
			cTLvl.getRPr().getColorArray(0).setVal(dgParseInput.getDefColour());
		}
		
		if( dgParseInput.getFontSize()>0 )
		{
			if(!cTLvl.isSetRPr())
			{
				cTLvl.addNewRPr();
			}
			if(cTLvl.getRPr().getSzList().isEmpty())
			{
				cTLvl.getRPr().addNewSz();
			}
			cTLvl.getRPr().getSzArray(0).setVal(BigInteger.valueOf(dgParseInput.getFontSize()*2));
		}
		
		if(!cTLvl.isSetLvlJc())
		{
			cTLvl.addNewLvlJc().setVal(STJcImpl.LEFT);
		}
		
		UpdateCurrentLeftForParser(dgInput,dgParseInput);
		ind1.setLeft(BigInteger.valueOf(dgParseInput.getCurrentLeft()));
		
		if(ind1.isSetHanging())
		{
			int lhangVal = ((BigInteger) ind1.getHanging()).intValue();
			if(l_LveltextChars!=l_exstChars)
			{
				lhangVal = Math.round(((lhangVal-180)*l_LveltextChars/l_exstChars))+180;
				ind1.setHanging(BigInteger.valueOf(lhangVal));
			}
		}
		else
		{
			int lhangVal = 360;
			if(dgParseInput.getFontSize()>0)
			{
				lhangVal = (l_LveltextChars*(16*dgParseInput.getFontSize()+10))+190;
			}
			else
			{
				lhangVal = (l_LveltextChars*170)+190; 
			}
			if(l_LveltextChars==3)
			{
				lhangVal = lhangVal+20;
			}
			ind1.setHanging(BigInteger.valueOf(lhangVal));
		}
	}

	
	private static CTLvl getExistingLevelFromList(CTAbstractNum cTAbstractNum, BigInteger iChkLevel) {
		Iterator<CTLvl> l_lvlItr = cTAbstractNum.getLvlList().iterator();
		while(l_lvlItr.hasNext())
		{
			CTLvl l_LvlObj = l_lvlItr.next();
			if(l_LvlObj.getIlvl().compareTo(iChkLevel)==0)
			{
				return l_LvlObj;				
			}
		}
		return null;
	}
	
	private static void SetStyleForRun(XWPFRun lCreatedRun,	DocGenParserInput dgParseInput) 
	{	
		lCreatedRun.setBold(dgParseInput.isBold());
		lCreatedRun.setItalic(dgParseInput.isItallic());		
		lCreatedRun.setStrikeThrough(dgParseInput.isStrikeThrough());
		if(dgParseInput.isUnderline())
		{
			lCreatedRun.setUnderline(UnderlinePatterns.SINGLE);
		}
		if(!"".equalsIgnoreCase(dgParseInput.getColor()))
		{
			lCreatedRun.setColor(dgParseInput.getColor());
		}
		if(dgParseInput.getFontSize()>0)
		{
			lCreatedRun.setFontSize(dgParseInput.getFontSize());
		}
		if(!"".equalsIgnoreCase(dgParseInput.getFontFamily()))
		{
			lCreatedRun.setFontFamily(dgParseInput.getFontFamily());
		}
		if(!"".equalsIgnoreCase(dgParseInput.getBackgroundColor()))
		{
			CTRPr lRPr = lCreatedRun.getCTR().isSetRPr() ? lCreatedRun.getCTR().getRPr() : lCreatedRun.getCTR().addNewRPr();
			if(lRPr.getShdList().isEmpty())
			{
				lRPr.addNewShd();
			}
			CTShd lRShd = lRPr.getShdArray(0);
			lRShd.setVal(STShd.CLEAR);
			lRShd.setColor("auto");			  
			lRShd.setFill(dgParseInput.getBackgroundColor());		
		}
	}

	private static String getReplaceableText(String text, org.w3c.dom.Node iValueNode,  String iPlaceHolder) 
	{
		if(iValueNode==null)
		{
			return "";
		}
		String l_attrValue = getValueByAttributeName(iValueNode,"value");
		if("Attribute".equalsIgnoreCase(iValueNode.getNodeName()))
		{			
			return l_attrValue;
		}		
		String lNodeValue = (iValueNode.getTextContent()==null)?"":iValueNode.getTextContent().trim();
		return lNodeValue;
	}

	private static String getValueByAttributeName(org.w3c.dom.Node iValueNode,String lAttrName) {
		String lValue = "";
		if(iValueNode.hasAttributes())
		{			
			NamedNodeMap attributesNode = iValueNode.getAttributes();			
			if( attributesNode.getNamedItem(lAttrName) != null) 
			{
				lValue = attributesNode.getNamedItem(lAttrName).getNodeValue();
				lValue = (lValue==null)?"":lValue;
			}			
		}
		return lValue;
	}

	private static void ParseContainingParagraphs(IBody bodyElem, Element iInputXML, Element valResult, boolean isValidation, DocGenInput dgInput, HashMap<String, org.w3c.dom.Node> tOKEN_MAPPINGS) 
	{
		if(bodyElem==null)
		{
			logger._log("com.opentext.apps.gc.docgen.DocumentGenerator",Severity.INFO,null,"Body elemet in containing paragraphs are empty");
			return;
		}
		ArrayList<XWPFParagraph> repeatedList = new ArrayList<XWPFParagraph>();
		int StartIndex = 0;
		String multiTagName = "";		
		List<XWPFParagraph> lParas = bodyElem.getParagraphs();
		XWPFParagraph[] lParasArray = new XWPFParagraph[lParas.size()];
		Iterator<XWPFParagraph> lparasIterator = lParas.iterator();

		int iterCount = 0;
		while(lparasIterator.hasNext())
		{
			lParasArray[iterCount++]=lparasIterator.next();
		}
		for(int indx=0;indx<lParasArray.length;indx++)
		{
			XWPFParagraph paragraph = lParasArray[indx];
			String pText = paragraph.getText();
			String multiOccurenceToken = RSVD_START_PATTERN+ELMTLVL_TOKEN+"1"+RSVD_END_PATTERN+RSVD_START_PATTERN+MULTIOCCURENCE_TOKEN+REPEAT_SEPARATOR;				
			Integer lCurrentIndex = getLevelFromParagraphText(pText);
			if((StartIndex>0) && (lCurrentIndex<=StartIndex))
			{
				GenerateMultirelatedParagraphs(0,iInputXML,multiTagName,repeatedList,StartIndex,0,bodyElem,(isValidation?valResult:null),dgInput);
				RemoveParagraphsFromDocument(repeatedList);
				StartIndex = 0;
				repeatedList.clear();
				multiTagName = "";					
			}
			if(StartIndex>0)
			{
				if(repeatedList != null) {
					repeatedList.add(paragraph);						
				}
			}
			else if(pText.trim().startsWith(multiOccurenceToken) && (StartIndex==0) && (pText.indexOf(RSVD_END_PATTERN)>pText.indexOf(multiOccurenceToken)+1))
			{
				StartIndex = 1;
				if(repeatedList != null) {
					repeatedList.add(paragraph);					
				}
				String lText = pText.trim().substring(multiOccurenceToken.length());
				multiTagName = lText.substring(0, lText.indexOf(RSVD_END_PATTERN));
			}				
			else
			{	
				String lNestedFor = getNestedElementText(pText);
				if("".equalsIgnoreCase(lNestedFor))
				{
					checkAndReplaceTokensInParagraph(paragraph,valResult,isValidation,true,tOKEN_MAPPINGS, dgInput);
				}
				else
				{
					org.w3c.dom.Node lRepeatableElement = iInputXML.getElementsByTagName(REPEATABLE_NODE_NAME).item(0);
					ArrayList<Element> lNestedElem = getMatchingElementsFromData(lNestedFor,lRepeatableElement );					
					String lNestedText = getTextForIteration(pText,lNestedFor);
					if(lNestedElem!=null && (!"".equalsIgnoreCase(lNestedText)) && (lNestedElem.size()>0))
					{
						for(int i=0;i<lNestedElem.size();i++)
						{
							ArrayList<Element> lChildElements = getMatchingElementsFromData(lNestedText, lNestedElem.get(i));						
							if(lChildElements.size()>0)
							{
								String lStyleClass = getValueByAttributeName(lNestedElem.get(i),"class");
								updateDefaultNumIfExist(paragraph,dgInput);
								dgInput.setParaLeft(getParaLeft(paragraph, paragraph.getDocument()));
								CreateNestedParagraphs(paragraph,0,((isValidation && i==0)?valResult:null),lChildElements,lNestedText,bodyElem,dgInput, null, lStyleClass, null,"");
								dgInput.setExstAbstractNum(null);
								dgInput.setParaLeft(0);
								dgInput.createdIds.clear();
							}
							
						}
						RemoveParagraphFromDocument(paragraph);
					}
					else
					{
						checkAndReplaceTokensInParagraph(paragraph,valResult,isValidation,true,tOKEN_MAPPINGS, dgInput);
					}
				}
				
			}			
		} 
		if(StartIndex>0)
		{
			GenerateMultirelatedParagraphs(0,iInputXML,multiTagName,repeatedList,StartIndex,0,bodyElem,(isValidation?valResult:null),dgInput);
			RemoveParagraphsFromDocument(repeatedList);
			StartIndex = 0;
			repeatedList.clear();
			multiTagName = "";
		}
	}
	
	private static void updateDefaultNumIfExist(XWPFParagraph paragraph, DocGenInput dgInput) {
		if(paragraph.getNumID()!=null && paragraph.getCTP().getPPr().isSetNumPr())
		{
			XWPFNumbering lNum = paragraph.getDocument().getNumbering();
			XWPFAbstractNum labstractNUm = lNum.getAbstractNum(lNum.getAbstractNumID(paragraph.getNumID()));
			if(labstractNUm !=null)
			{
				dgInput.setExstAbstractNum(labstractNUm.getCTAbstractNum());
			}
		}		
	}

	private static ArrayList<Element> getMatchingElementsFromData(String iNodeText, org.w3c.dom.Node node) 
	{
		ArrayList<Element> lReturnElements = new ArrayList<Element>();
		if(node == null)
		{
			return lReturnElements;
		}
		NodeList lChildren = node.getChildNodes();		
		Boolean isAttribute = false;
		String lCompareText = iNodeText;
		if(iNodeText.startsWith(ATTR_TEXT_START) && iNodeText.endsWith(ATTR_TEXT_END))
		{
			isAttribute = true;
			lCompareText = lCompareText.substring(ATTR_TEXT_START.length(), lCompareText.indexOf(ATTR_TEXT_END));
		}
		for(int num=0;num<lChildren.getLength();num++)
		{			
			org.w3c.dom.Node lChild = lChildren.item(num);
			String lNodeName = lChild.getNodeName();
			if("#text".equals(lNodeName))
			{
				continue;
			}
			else
			{				
				if(lChild.getNodeType()==1 && (!"".equalsIgnoreCase(lNodeName)))
				{
					Boolean isValidNode = isAttribute?((Element)lChild).hasAttribute(lCompareText):lCompareText.equalsIgnoreCase(lNodeName);
					if(isValidNode)
					{
						lReturnElements.add((Element)lChild);
					}
				}
			}			
		}		
		return lReturnElements;
	}
	
	private static String getTextForIteration(String pText, String lNestedFor) 
	{
		return getElementFromPattern(pText.stripLeading(),RSVD_START_PATTERN,RSVD_END_PATTERN, (RSVD_START_PATTERN+NESTED_START+REPEAT_SEPARATOR+lNestedFor+RSVD_END_PATTERN+RSVD_START_PATTERN+NESTED_TEXT+REPEAT_SEPARATOR));
	}

	private static String getNestedElementText(String pText) 
	{
		return getElementFromPattern(pText.stripLeading(),RSVD_START_PATTERN,RSVD_END_PATTERN, RSVD_START_PATTERN+NESTED_START+REPEAT_SEPARATOR);
	}
	
	private static String getElementFromPattern(String iLongtext,String iStartPattern,String iEndPattern, String iStartText) 
	{
		String lNestedString = "";
		String lStartText = iStartText;
		if(iLongtext.startsWith(lStartText))
		{
			int lEndIndex = iLongtext.indexOf(iEndPattern, lStartText.length()-1);
			int lNextStartIndex = iLongtext.indexOf(iStartPattern, lStartText.length()-1);
			if(lEndIndex>0 && (lNextStartIndex==-1 || lNextStartIndex>lEndIndex))
			{
				lNestedString = iLongtext.substring(lStartText.length(), lEndIndex);
			}
		}
		return lNestedString;
	}
	
	private static Integer getLevelFromParagraphText(String pText) 
	{
		int lIndex = 0;
		String lLeveltext = RSVD_START_PATTERN+ELMTLVL_TOKEN;
		if(pText.trim().startsWith(lLeveltext) &&  pText.indexOf(RSVD_END_PATTERN)>lLeveltext.length())
		{
			String lText = pText.trim().substring(lLeveltext.length(),pText.trim().indexOf(RSVD_END_PATTERN));
			try
			{
				lIndex = lText.length()>0?Integer.parseInt(lText):0;
			}
			catch (NumberFormatException e) 
			{
				logger._log("com.opentext.apps.gc.docgen.DocumentGenerator", Severity.ERROR, e, "Error while parsing Paragraph starting with "+pText.substring(0, 10)+"..... and ending with ......"+pText.substring(pText.length()-11, pText.length()-1));
				throw new DocGenApplicationException(DocGenAlertMessages.PARSING_FAILURE_PARAGRAPH);
			}
		} 
		return lIndex;
	}

	private static void RemoveParagraphsFromDocument(ArrayList<XWPFParagraph> repeatedList) 
	{	
		for(int ix=0;ix<repeatedList.size();ix++)
		{
			RemoveParagraphFromDocument(repeatedList.get(ix));
		}
	}
	
	private static void RemoveParagraphFromDocument(XWPFParagraph iParagraph) 
	{
		XmlCursor cur = iParagraph.getCTP().newCursor();
		cur.removeXml();
		cur.dispose();
	}

	private static void RepeatRelatedRows(XWPFTable table, XWPFTableRow repeatableRow, int rowPos, String occurenceElement, Element iInputXML, Element valResult, boolean isValidation, DocGenInput dgInput) 
	{
		int insPos = 1;
		if(repeatableRow!=null)
		{
			NodeList repeatElements = iInputXML.getElementsByTagName(occurenceElement);
			Boolean logTokens = true;
			int elemLength = repeatElements.getLength();
			HashMap<String, org.w3c.dom.Node> mappingHM = new HashMap<String, org.w3c.dom.Node>();
			for(int ix=0;ix<elemLength;ix++)
			{
				org.w3c.dom.Node rptElem = repeatElements.item(ix);				
				PrepareMappingContent(mappingHM,(Element) rptElem, dgInput);

				XWPFTableRow newRow = new XWPFTableRow((CTRow) repeatableRow.getCtRow().copy(),table);
				Boolean firstText = true;
				for (XWPFTableCell cells : newRow.getTableCells()) 
				{
					for (XWPFParagraph cellParagraph : cells.getParagraphs()) 
					{
						String pText = cellParagraph.getText();
						int removableLength = pText.indexOf(RSVD_END_PATTERN)+RSVD_END_PATTERN.length();
						if(pText!=null)
						{							
							if (firstText) 
							{								
								RemoveRunsTillLength(cellParagraph,removableLength);
								firstText = false;
							}
							checkAndReplaceTokensInParagraph(cellParagraph,valResult,(isValidation && logTokens),logTokens,mappingHM, dgInput);
						}
						firstText = false;
					}						
				}
				table.addRow(newRow, rowPos+insPos);								
				insPos++;
				logTokens = false;
				mappingHM.clear();
			}
			table.removeRow(rowPos);						
		}
	}

	private static void RemoveRunsTillLength(XWPFParagraph para, int removableLength) 
	{		
		int accumLength = 0;
		int rmvindx = 0;
		for(XWPFRun lRun : para.getRuns())
		{	
			String lrunText = lRun.getText(0);
			String l_runFulltext = lRun.text();

			if(lrunText!=null && !("".equals(lrunText)))
			{							
				int lRunLength = l_runFulltext.length();
				if((accumLength+lRunLength)>removableLength)
				{
					SetTextOfTheRun(lRun,lrunText.substring((accumLength>0)?(removableLength-accumLength):removableLength));
					rmvindx--;
					break;
				}
				accumLength+=  l_runFulltext.length();
			}
			rmvindx++;			
		}
		for(int rmvi =rmvindx; rmvi>=0;rmvi--)
		{
			para.removeRun(rmvi);			
		}
	}

	private static int GenerateMultirelatedParagraphs(int iIndex,Element iInputXML, String multiTagName,ArrayList<XWPFParagraph> repeatedParaList, int iLevel, int iLlastParsedIndex, IBody bodyElem, Element valResult, DocGenInput dgInput) 
	{
		int multiSize = repeatedParaList.size();
		int lastParsedIndex = iLlastParsedIndex;		
		ArrayList<Element> repeatElements = getMatchingMultiElementsFromData(multiTagName, iInputXML, (iLevel==1));
		Boolean logTokens = true;
		int elemLength = repeatElements.size();
		for(int ix=0;ix<elemLength;ix++)
		{
			org.w3c.dom.Node currentElem = repeatElements.get(ix);
			CloneRelatedParagraph(repeatedParaList.get(iIndex),(Element) currentElem,repeatedParaList.get(0).getCTP().newCursor(),bodyElem,getRemovableTextLength(repeatedParaList.get(iIndex),iLevel,multiTagName),logTokens,valResult,dgInput);			
			logTokens = false;
			lastParsedIndex = iLlastParsedIndex;
			for(int iy = iIndex+1;iy<multiSize;iy++)
			{
				if(lastParsedIndex<iy)
				{
					XWPFParagraph para = repeatedParaList.get(iy);
					String pText = para.getText();
					int lvl = getLevelFromParagraphText(pText);
					String multiOccurenceToken = RSVD_START_PATTERN+ELMTLVL_TOKEN+lvl+RSVD_END_PATTERN+RSVD_START_PATTERN+MULTIOCCURENCE_TOKEN+REPEAT_SEPARATOR;
					if(lvl<=iLevel)
					{
						break;
					}
					lastParsedIndex = iy;
					if(pText.trim().startsWith(multiOccurenceToken) && (pText.indexOf(RSVD_END_PATTERN)>pText.indexOf(multiOccurenceToken)+1))
					{		
						String lText = pText.trim().substring(multiOccurenceToken.length());
						String lmultiTagName = lText.substring(0, lText.indexOf(RSVD_END_PATTERN));
						lastParsedIndex = GenerateMultirelatedParagraphs(iy,(Element) currentElem,lmultiTagName,repeatedParaList,lvl,lastParsedIndex,bodyElem,valResult,dgInput);
					}
					else
					{
						CloneRelatedParagraph(para,(Element) currentElem,repeatedParaList.get(0).getCTP().newCursor(),bodyElem,getRemovableTextLength(para,lvl,""),true,valResult,dgInput);
					}
				}
			}
			if(valResult!=null)
			{
				break;
			}
		}
		return lastParsedIndex;
	}
	
	private static ArrayList<org.w3c.dom.Element> getMatchingMultiElementsFromData(String multiTagName, org.w3c.dom.Element iParentElement, boolean isFirstLevel) {
		ArrayList<org.w3c.dom.Element> lReturnElements = new ArrayList<org.w3c.dom.Element>();
		if(isFirstLevel)
		{
			NodeList lRepeatElements = iParentElement.getElementsByTagName(REPEATABLE_NODE_NAME);
			if(lRepeatElements != null && lRepeatElements.item(0)!=null)
			{
				org.w3c.dom.Element lRepeatableElement = (org.w3c.dom.Element) lRepeatElements.item(0);
				int l_multiIndex = multiTagName.indexOf(">");
				if(l_multiIndex<0 && (!multiTagName.contains("{")))
				{
					NodeList lElems = lRepeatableElement.getElementsByTagName(multiTagName);
					for(int il=0;il<lElems.getLength();il++)
					{
						lReturnElements.add((org.w3c.dom.Element) lElems.item(il));
					}
				}
				else
				{
					String lFindtext = "ContentRoot";
					String lElemText = multiTagName;
					if(l_multiIndex>0)
					{
						lFindtext = multiTagName.substring(0, l_multiIndex).trim();
						lElemText = multiTagName.substring(l_multiIndex+1).trim();
					}
					ArrayList<org.w3c.dom.Element> lElems = getMatchingElementsFromData(lFindtext,lRepeatableElement );
					for(int im=0;im<lElems.size();im++)
					{
						lReturnElements.addAll( getMatchingElementsFromData(lElemText,lElems.get(im)));				
					}
				}
			}
		}
		else
		{
			return getMatchingElementsFromData(multiTagName,iParentElement);
		}
		return lReturnElements;
	}
	
	private static void CreateNestedParagraphs(XWPFParagraph paragraph, int iLevel, Element iValResult,
			ArrayList<Element> lNestedElem, String lNestedText, IBody bodyElem, DocGenInput dgInput,CTAbstractNum cTAbstractNum, String iNumberingStyle, DocGenParserInput iDGParserInput, String iPrevLevel) {
		int elemLength = lNestedElem.size();
		if(iValResult!=null)
		{
			if(elemLength>0)
			{
				CloneRelatedRepeatedParagraph(paragraph,lNestedElem.get(0),null,bodyElem,getRemovableTextForNestedParagraph(lNestedText,paragraph),true,iValResult,dgInput,true,null,null, false);
			}
		}
		else
		{
			CTAbstractNum lCTAbstractNum=cTAbstractNum;
			String lStyleClass= "";
			XWPFDocument lDoc=paragraph.getDocument();
			BigInteger numID =null;
			BigInteger exstNumId=null;
			BigInteger lNewId=null;
			DocGenParserInput dgnew=(iDGParserInput==null)?(new DocGenParserInput()):new DocGenParserInput(iDGParserInput);
			int lLevelLeft = 0;
			String lExstRoute="";
			int lNumCount = 0;
				
			for(int ix=0;ix<elemLength;ix++)
			{
				if(ix==0) {
					lLevelLeft = dgnew.getCurrentLeft();
					lExstRoute = dgnew.getLvlRoute();
					exstNumId = dgnew.getNumID();
				}
				String lnumString = getValueByAttributeName(lNestedElem.get(ix),"numbering");
				if("OFF".equalsIgnoreCase(lnumString))
				{					
					DocGenParserInput dgcur = new DocGenParserInput();
					dgcur.setAddlLevel((iDGParserInput==null)?0:(iDGParserInput.getAddlLevel()+1));
					dgcur.setNumSysCount(dgnew.getNumSysCount()+1);
					UpdateCurrentLeftForParser(dgInput, dgcur);
					
					ArrayList<Element> lChildElements = getMatchingElementsFromData(lNestedText, lNestedElem.get(ix));
					
					XmlCursor lNewCursor = paragraph.getCTP().newCursor();
					CloneRelatedRepeatedParagraph(paragraph,lNestedElem.get(ix),lNewCursor,bodyElem,getRemovableTextForNestedParagraph(lNestedText,paragraph),(ix==0 && iLevel==0),null,dgInput,true,dgcur,lCTAbstractNum, true);
					lNewCursor.dispose();				
					if(lChildElements.size()>0)
					{
						CreateNestedParagraphs(paragraph, 0, null, lChildElements, lNestedText, bodyElem, dgInput, null, lStyleClass,dgcur,"");
					}
				}
				else
				{
					if(lCTAbstractNum==null)
					{
						lNewId=getNewAbstractNumberingId(lDoc,dgInput);
						DocumentFactory<CTAbstractNum> lNumfact = CTAbstractNum.Factory;
						lCTAbstractNum = lNumfact.newInstance();
						lCTAbstractNum.setAbstractNumId(lNewId);
						numID = lDoc.getNumbering().addNum(lNewId);
						dgInput.addCreatedAbstractIds(lNewId);
						dgnew.setNumID(numID);
					}					
					if(lNumCount==0)
					{
						lStyleClass = getValueByAttributeName(lNestedElem.get(ix),"class");						
						
						int diffInt = IsDifferenceInLevel(lCTAbstractNum, false, dgnew, lStyleClass);
						if(diffInt>0 && lNewId==null)
						{
							AddNumberingForLvlOverride(dgnew, lDoc, lStyleClass, false, dgInput, dgInput.getParaLeft(), null, "S-");
						}
						else
						{
							XWPFRun lRun = paragraph.getRuns().get(0);
							CreateDefaultValuesForParserInput(lRun,dgnew);
							dgInput.getOrCreateNumInput("S", lRun);
							getNewNumberingLevel(dgnew,lDoc,lStyleClass,false,lCTAbstractNum,dgInput.getParaLeft(),1,dgInput);
							String lrouteText= getRouteTextByNumClass(lStyleClass,"S-");
							if(iLevel==0)
							{
								lrouteText = dgnew.getNumSysCount()+"-"+lrouteText;
							}						
							dgnew.setLvlRoute(lExstRoute+lrouteText+";");
							dgnew.resetDefaultFontStyle();
						}					
					}
					lNumCount++;
					String lPrevLevel = iPrevLevel+""+lNumCount+";";
					ArrayList<Element> lChildElements = getMatchingElementsFromData(lNestedText, lNestedElem.get(ix));
					dgnew.setIsNumUsed(lChildElements.size()>0);
					dgnew.setPrevNums(lPrevLevel);
					XmlCursor lNewCursor = paragraph.getCTP().newCursor();
					CloneRelatedRepeatedParagraph(paragraph,lNestedElem.get(ix),lNewCursor,bodyElem,getRemovableTextForNestedParagraph(lNestedText,paragraph),(ix==0 && iLevel==0),null,dgInput,true,dgnew,lCTAbstractNum, true);
					lNewCursor.dispose();				
					if(lChildElements.size()>0)
					{
						if(exstNumId!=null && lNewId==null)
						{
							dgnew.setNumID(exstNumId);
						}						
						CreateNestedParagraphs(paragraph, iLevel+1, null, lChildElements, lNestedText, bodyElem, dgInput, lCTAbstractNum, lStyleClass,dgnew,lPrevLevel);
					}
				}
				if(ix==(elemLength-1) && (lNumCount>0))
				{
					dgnew.setNumID(exstNumId);
					dgnew.setNumLevel(dgnew.getNumLevel()-1);
					dgnew.setAddlLevel(dgnew.getAddlLevel()-1);
					dgnew.setLvlRoute(lExstRoute);
					dgnew.setCurrentLeft(lLevelLeft);
				}				
			}
			if(lNewId!=null)
			{
				CreateTentativeLevels(lCTAbstractNum, dgInput);
				XWPFAbstractNum abstractNum = new XWPFAbstractNum(lCTAbstractNum);			
				BigInteger abstractNumID = lDoc.getNumbering().addAbstractNum(abstractNum);						
				lDoc.getNumbering().getNum(numID).getCTNum().getAbstractNumId().setVal(abstractNumID);
				AddOverrideNumsToDocument(lDoc,abstractNumID,dgInput,dgnew,lCTAbstractNum);
			}
		}
	}

	private static int getParaLeft(XWPFParagraph paragraph, XWPFDocument lDoc) {
		XWPFNumbering ldocNumbering = lDoc.getNumbering();
		if(ldocNumbering != null)
		{
			if(paragraph.getNumID()!=null)
			{
				BigInteger paraLevel = paragraph.getNumIlvl();			
				if(paraLevel !=null)
				{
					XWPFNum lNum = ldocNumbering.getNum(paragraph.getNumID());
					if(lNum!=null && lNum.getCTNum().getAbstractNumId()!=null)
					{
						XWPFAbstractNum lAbstractNum = ldocNumbering.getAbstractNum(lNum.getCTNum().getAbstractNumId().getVal());
						if(lAbstractNum!=null && lAbstractNum.getCTAbstractNum()!=null && lAbstractNum.getCTAbstractNum().getLvlList()!=null)
						{
							Iterator<CTLvl> l_lvlItr = lAbstractNum.getCTAbstractNum().getLvlList().iterator();
							while(l_lvlItr.hasNext())
							{
								CTLvl l_LvlObj = l_lvlItr.next();
								if(l_LvlObj.getIlvl().compareTo(paraLevel)==0)
								{
									if(l_LvlObj.getPPr()!=null && l_LvlObj.getPPr().getInd()!=null && l_LvlObj.getPPr().getInd().getLeft()!=null)
									{
										int l_leftVal = ((BigInteger) l_LvlObj.getPPr().getInd().getLeft()).intValue();
										if(l_leftVal>0)
										{
											return l_leftVal;
										}
									}
									break;
								}
							}
						}
					}
				}
			}
			int lIndLeft= paragraph.getIndentationLeft();
			if(lIndLeft>0)
			{
				return lIndLeft;
			}
		}
		return 0;
	}
	
	private static int UpdateCurrentLeftForParser(DocGenInput dgInput,  DocGenParserInput dgParseInput)
	{
		int indLeft = 0;
		if(dgInput.getExstAbstractNum()!=null)
		{
			CTLvl lExstLvl = dgInput.getExstAbstractNum().getLvlArray(dgParseInput.getAddlLevel());
			if(lExstLvl!=null && lExstLvl.isSetPPr() && lExstLvl.getPPr().isSetInd() && lExstLvl.getPPr().getInd().isSetLeft())
			{
				indLeft = ((BigInteger)lExstLvl.getPPr().getInd().getLeft()).intValue();
			}
		}
		if(indLeft>0)
		{
			dgParseInput.setCurrentLeft(indLeft);
		}
		else
		{
			indLeft = 360;
			if(dgInput.getParaLeft()>0)
			{
				indLeft = dgInput.getParaLeft();
			}
			if(dgParseInput.getCurrentLeft()>0)
			{
				indLeft = dgParseInput.getCurrentLeft()+720;
			}
			else
			{
				indLeft = indLeft+(dgParseInput.getAddlLevel())*720;
			}
			dgParseInput.setCurrentLeft(indLeft);
		}
		return indLeft;
	}

	private static int getRemovableTextForNestedParagraph(String lNestedText, XWPFParagraph paragraph) {
		String lText = RSVD_START_PATTERN+NESTED_TEXT+REPEAT_SEPARATOR+lNestedText+RSVD_END_PATTERN;
		int lIndex = paragraph.getText().indexOf(lText);
		if(lIndex>0)
		{
			return (lIndex+lText.length());
		}
		return 0;
	}

	private static int getRemovableTextLength(XWPFParagraph para, int lvl, String multiTagName) {
		int rmvLength = para.getText().indexOf(RSVD_START_PATTERN+ELMTLVL_TOKEN)+(RSVD_START_PATTERN+ELMTLVL_TOKEN+lvl+RSVD_END_PATTERN).length();
		if(multiTagName!=null && multiTagName.length()>0)
		{
			rmvLength = rmvLength+(RSVD_START_PATTERN+RSVD_END_PATTERN+REPEAT_SEPARATOR).length()+MULTIOCCURENCE_TOKEN.length()+multiTagName.length();
		}		
		return rmvLength;
	}

	private static void CloneRelatedParagraph(XWPFParagraph para, Element item, XmlCursor xmlCursor, IBody bodyElem, int rmvLength, Boolean logTokens, Element valResult, DocGenInput dgInput) 
	{
		DocGenParserInput ldgParserInput = null;
		if(valResult==null)
		{
			ldgParserInput = new DocGenParserInput();
			ldgParserInput.setCurrentLeft(getParaLeft(para, para.getDocument()));
		}
		CloneRelatedRepeatedParagraph(para, item, xmlCursor, bodyElem, rmvLength, logTokens, valResult, dgInput, true, ldgParserInput,null, false);
	}
	
	private static void CloneRelatedRepeatedParagraph(XWPFParagraph para, Element item, XmlCursor xmlCursor, IBody bodyElem, int rmvLength, Boolean logTokens, Element valResult, DocGenInput dgInput,
			boolean iIgnoreTagPresence, DocGenParserInput dgnew, CTAbstractNum lCTAbstractNum, boolean overrideppr) {
		int removableLength = rmvLength;
		XWPFParagraph newPara = null;
		if(valResult==null)
		{
			newPara = bodyElem.insertNewParagraph(xmlCursor);
			xmlCursor.toNextToken();			
		}
		HashMap<String, org.w3c.dom.Node> mappingHM = new HashMap<String, org.w3c.dom.Node>();
		PrepareMappingContent(mappingHM,item , dgInput);
		TreeMap<Integer, String> paragraphTokens = new TreeMap<Integer,String>();
		TreeMap<Integer, String> runsTokens = new TreeMap<Integer,String>();
		Set<String> lContKeys = mappingHM.keySet();
		paragraphTokens.putAll(patternCounter(para.getText().substring(rmvLength),lContKeys,rmvLength,dgInput,iIgnoreTagPresence));
		
		int accumLength = 0;
		if(newPara!=null)
		{
			cloneParagraphPpr(newPara,para);
			if(dgnew!=null  && overrideppr )
			{
				if( dgnew.getNumID()!=null)
				{
					newPara.setNumID(dgnew.getNumID());
					newPara.setVerticalAlignment(TextAlignment.CENTER);
					if(para.getCTP().getPPr()!=null && para.getCTP().getPPr().isSetJc())
					{
						if(!newPara.getCTP().getPPr().isSetJc())
						{
							newPara.getCTP().getPPr().addNewJc().set(para.getCTP().getPPr().getJc().copy());
						}
					}
					else
					{
						newPara.getCTP().getPPr().addNewJc().setVal(STJc.LEFT);
					}
					if(newPara.getCTP().getPPr().isSetInd())
					{
						newPara.getCTP().getPPr().unsetInd();
					}
					if(!newPara.getCTP().getPPr().getNumPr().isSetIlvl())
					{
						newPara.getCTP().getPPr().getNumPr().addNewIlvl();
					}
					newPara.getCTP().getPPr().getNumPr().getIlvl().setVal(BigInteger.valueOf(dgnew.getNumLevel()));
				}
				else
				{
					
					if(newPara.getCTP().getPPr()!=null && newPara.getCTP().getPPr().isSetNumPr())
					{
						newPara.getCTP().getPPr().unsetNumPr();
					}
					if(newPara.getCTP().getPPr()!=null && newPara.getCTP().getPPr().isSetPStyle())
					{
						XWPFStyle lStyle = newPara.getDocument().getStyles().getStyle(newPara.getCTP().getPPr().getPStyle().getVal());
						if(lStyle!=null && lStyle.getCTStyle().getPPr().isSetNumPr())
						{
							newPara.setNumID(BigInteger.ZERO);
							if(!newPara.getCTP().getPPr().getNumPr().isSetIlvl())
							{
								newPara.getCTP().getPPr().getNumPr().addNewIlvl();
							}
							newPara.getCTP().getPPr().getNumPr().getIlvl().setVal(BigInteger.ZERO);
						}
					}
					if(!newPara.getCTP().getPPr().isSetInd())
					{
						newPara.getCTP().getPPr().addNewInd();
					}
					if(newPara.getCTP().getPPr().getInd().isSetHanging())
					{
						newPara.getCTP().getPPr().getInd().unsetHanging();
					}
					newPara.getCTP().getPPr().getInd().setLeft(BigInteger.valueOf(dgnew.getCurrentLeft()));
				}
			}
		}
		TreeMap<Integer, ArrayList<String>> parsableRuns = new TreeMap<Integer, ArrayList<String>>();
		int lRunIndex = 0;
		for(XWPFRun lRun : para.getRuns())
		{	
			String lrunText = lRun.getText(0);
			String l_runFulltext = lRun.text();
			if(lrunText==null || "".equals(lrunText))
			{
				if(newPara != null)
				{
					XWPFRun lNewRun = newPara.createRun();
					cloneRun(lNewRun, lRun,lrunText);
					lRunIndex++;
				}
			}
			else
			{
				int lRunLength = lrunText.length();
				if(lRunLength>removableLength)
				{
					if(newPara != null)
					{
						XWPFRun lNewRun = newPara.createRun();
						cloneRun(lNewRun, lRun,"");
						ArrayList<String> lParsableTokens = ReplaceMappingsinClonedRunForparagraph(mappingHM,lNewRun,lRun,removableLength,logTokens,iIgnoreTagPresence,paragraphTokens);
						if(lParsableTokens!=null)
						{
							parsableRuns.put(lRunIndex, lParsableTokens);
						}
						lRunIndex++;
					}
					if(logTokens)
					{
						runsTokens.putAll(patternCounter(lrunText.substring(removableLength),lContKeys,accumLength+rmvLength , dgInput,iIgnoreTagPresence));
					}					
					removableLength = 0;
				}
				else
				{
					removableLength = removableLength-lRunLength;
				}
			}
			accumLength+=  (l_runFulltext!=null)?l_runFulltext.length():0;			
		}
		if(newPara != null)
		{
			if(!parsableRuns.isEmpty())
			{
				CreateParsedRunsInParagraph(parsableRuns,newPara,mappingHM,dgInput,xmlCursor,dgnew,lCTAbstractNum);
			}
			removeNewLineatTheEnd(newPara);
		}
		if(logTokens)
		{
			mappingMismatchLogger(paragraphTokens, runsTokens, para.getText(), 50,valResult);
		}
		
	}

	private static org.w3c.dom.Document getNewOutputDocument() {
		try 
		{
			DocumentBuilderFactory dbf = DocumentBuilderFactory.newInstance();
			DocumentBuilder builder = dbf.newDocumentBuilder();			
			org.w3c.dom.Document doc = builder.newDocument();
			Element l_outNode = doc.createElement("DocumentGenerationOutput");
			doc.appendChild(l_outNode);
			Element outLocationElement = doc.createElement("OutputRelativePath");
			l_outNode.appendChild(outLocationElement);
			Element validatorElement = doc.createElement("ValidatorResult");
			l_outNode.appendChild(validatorElement);
			return doc;
		} 
		catch (ParserConfigurationException e) 
		{
			logger._log("com.opentext.apps.gc.docgen.DocumentGenerator", Severity.ERROR, e, "Error occured while preparing output"+e.getMessage());
			throw new DocGenApplicationException(DocGenAlertMessages.PARSER_CONFIGURATION_ERROR);
		}
		catch(Exception e) 
		{
			logger._log("com.opentext.apps.gc.docgen.DocumentGenerator", Severity.ERROR, e, "Error occured while preparing output"+e.getMessage());
			throw new DocGenApplicationException(DocGenAlertMessages.DOCUMENT_BUILDER_FAILURE);			
		}
	}

	private static ArrayList<String> ReplaceMappingsinClonedRunForparagraph(HashMap<String, org.w3c.dom.Node> mappingHM, XWPFRun lNewRun, XWPFRun oldRun,int startIndex, Boolean logTokens, boolean iIgnoreTagPresence, TreeMap<Integer, String> paragraphTokens) 
	{	
		String text = oldRun.getText(0).substring(startIndex);
		ArrayList<String> lSplTokens=null;
		try
		{
			for(Entry<Integer, String> tkn : paragraphTokens.entrySet())
			{
				if(text.contains(tkn.getValue()))
				{
					org.w3c.dom.Node lNode = mappingHM.get(tkn.getValue());					
					if(lNode != null)
					{
						String lValueType = getValueByAttributeName((org.w3c.dom.Node) lNode,"datatype");
						if("html".equalsIgnoreCase(lValueType))
						{						
							if(lSplTokens==null)
							{
								lSplTokens = new ArrayList<String>();
							}
							lSplTokens.add(tkn.getValue());
						}									
						else
						{
							String l_replacingText=getReplaceableText(text,lNode,tkn.getValue());
							if(l_replacingText!=null && ((!"".equalsIgnoreCase(l_replacingText))||iIgnoreTagPresence))
							{
								text = text.replace(tkn.getValue(), l_replacingText);							
							}
						}
					}
					else
					{
						if(iIgnoreTagPresence)
						{
							text = text.replace(tkn.getValue(), "");	
						}
					}
					
				}
			}
			
		}
		catch(OfficeXmlFileException e)
		{
			logger._log("com.opentext.apps.gc.docgen.DocumentGenerator", Severity.ERROR, e, "Error while Replacing Mappings in Cloned Run for paragraph.");
			throw new DocGenApplicationException(DocGenAlertMessages.REPLACE_MAPPING_IN_CLONED_RUN_FOR_PARAGRAPH_XML_ERROR);
		}
		catch(Exception e)
		{
			logger._log("com.opentext.apps.gc.docgen.DocumentGenerator", Severity.ERROR, e, "Error while Replacing Mappings in Cloned Run for paragraph.");
			throw new DocGenApplicationException(DocGenAlertMessages.REPLACE_MAPPING_IN_CLONED_RUN_FOR_PARAGRAPH);
		}
		SetTextOfTheRun(lNewRun,text, 0);
		return lSplTokens;
	}

	private static void PrepareMappingContent(HashMap<String, org.w3c.dom.Node> mappingHM,Element item, DocGenInput dgInput) 
	{		
		NodeList childList = item.getChildNodes();
		String START_PATTERN = dgInput.getStartPattern();
		String END_PATTERN = dgInput.getEndPattern();
		for (int j = 0; j < childList.getLength(); j++) 
		{
			org.w3c.dom.Node childNode = (org.w3c.dom.Node) childList.item(j);
			if(!((org.w3c.dom.Node) childNode).getNodeName().equals("#text") && (((org.w3c.dom.Node) childNode).getNodeType()==1)) 
			{
				try
				{
					//String lValue = (childList.item(j).getTextContent()==null)?"":childList.item(j).getTextContent().trim();
					mappingHM.put(START_PATTERN+childNode.getNodeName()+END_PATTERN, childList.item(j));
				}
				catch(Exception e)
				{
					logger._log("com.opentext.apps.gc.docgen.DocumentGenerator", Severity.ERROR, e, "Error while Preparing Mapping Content.");
					throw new DocGenApplicationException(DocGenAlertMessages.MAPPING_BUILDER_ERROR);
				}
			}
		}
	}

	private static void cloneRun(XWPFRun clone, XWPFRun source, String irunText) 
	{
		try
		{			
			clone.getCTR().set(source.getCTR().copy());
			SetTextOfTheRun(clone,irunText);
		}
		catch(Exception e)
		{
			logger._log("com.opentext.apps.gc.docgen.DocumentGenerator", Severity.ERROR, e, "Error while cloning the runs.");
			throw new DocGenApplicationException(DocGenAlertMessages.CLONE_RUN_ERROR);
		}
	}

	private static void cloneParagraphPpr(XWPFParagraph clone, XWPFParagraph source) {
		try
		{		
			clone.getCTP().set(source.getCTP().copy());	    
			CTR[] rArray = new CTR[0];
			clone.getCTP().setRArray(rArray);
		}
		catch(Exception e)
		{
			logger._log("com.opentext.apps.gc.docgen.DocumentGenerator", Severity.ERROR, e, "Error while cloning the paragraphs.");
			throw new DocGenApplicationException(DocGenAlertMessages.CLONE_PARAGRAPH_ERROR);
		}
	}

	public static TreeMap<Integer, String> patternCounter(String INPUT_STRING,Set<String> iContainingKeys, int accumLength, DocGenInput dgInput, boolean iIgnoreTagPresence) {
		TreeMap<Integer, String> TOKEN_FOUND = new TreeMap<Integer, String>();
		int lastIndex = 0, lEndIndex=0;		
		while (lastIndex != -1 && lEndIndex !=-1 ) 
		{
			try
			{
				lastIndex = INPUT_STRING.indexOf(dgInput.getStartPattern(), lastIndex);
				lEndIndex = INPUT_STRING.indexOf(dgInput.getEndPattern(),lastIndex+dgInput.getStartPattern().length());				
				if (lastIndex != -1 && lEndIndex != -1 ) 
				{
					String lToken = INPUT_STRING.substring(lastIndex, lEndIndex+dgInput.getEndPattern().length());
					if(iContainingKeys.contains(lToken) || iIgnoreTagPresence)
					{
						TOKEN_FOUND.put(accumLength+lastIndex+1,lToken);						
						lastIndex += lToken.length();
					}
					else
					{
						lastIndex = lEndIndex;
					}
				}				
			}
			catch(Exception e)
			{
				logger._log("com.opentext.apps.gc.docgen.DocumentGenerator", Severity.ERROR, e, "Error while counting the patterns.");
				throw new DocGenApplicationException(DocGenAlertMessages.PATTERN_COUNTER_ERROR);
			}
		}		
		return TOKEN_FOUND;
	}

	public static void mappingMismatchLogger(TreeMap<Integer, String> paragraphTokens, TreeMap<Integer, String> runsTokens,
			String INPUT_PARAGRAPHS, int PARAGRAPH_LIMITTER, Element valResult) {
		if(INPUT_PARAGRAPHS==null)
		{
			return;
		}
		String l_runTokenText="";
		String l_paraTokenText="";
		String lParaText = INPUT_PARAGRAPHS.trim();
		if(paragraphTokens.size()!=runsTokens.size())
		{
			org.w3c.dom.Document l_outDoc = null;
			Element l_paraElem =null;
			if(valResult!=null)
			{
				l_outDoc = valResult.getOwnerDocument();
				l_paraElem = l_outDoc.createElement("Paragraph");
				valResult.appendChild(l_paraElem);
				Element l_lengthNode = l_outDoc.createElement("ContentLength");
				l_paraElem.appendChild(l_lengthNode);
				int l_textLength = lParaText.length();
				l_lengthNode.setTextContent(""+l_textLength);
				Element l_startsNode = l_outDoc.createElement("StartsWith");
				l_paraElem.appendChild(l_startsNode);
				Element l_endsNode = l_outDoc.createElement("EndsWith");
				l_paraElem.appendChild(l_endsNode);
				if(l_textLength>40)
				{
					l_startsNode.setTextContent(lParaText.substring(0, 20));
					l_endsNode.setTextContent(lParaText.substring(l_textLength-20));
				}
				else if(l_textLength>20)
				{
					l_startsNode.setTextContent(lParaText.substring(0, 20));
					l_endsNode.setTextContent(lParaText.substring(20));
				}
				else if(l_textLength>0)
				{
					l_startsNode.setTextContent(lParaText);
				}
			}
			Iterator<Entry<Integer, String>> l_elemIterator = runsTokens.entrySet().iterator();
			while(l_elemIterator.hasNext())
			{
				Entry<Integer, String> l_entry = l_elemIterator.next();
				paragraphTokens.remove(l_entry.getKey());
				l_runTokenText+="{pos:"+l_entry.getKey()+", token:"+l_entry.getValue()+"}";				
			}
			Iterator<Entry<Integer, String>> l_pIterator = paragraphTokens.entrySet().iterator();
			while(l_pIterator.hasNext())
			{
				Entry<Integer, String> l_entry = l_pIterator.next();
				l_paraTokenText+="{pos:"+l_entry.getKey()+", token:"+l_entry.getValue()+"}";
				if(valResult !=null)
				{

					Element l_tokenNode = null;

					if(l_outDoc != null) {
						l_tokenNode = l_outDoc.createElement("MissingToken");						
					}

					if(l_paraElem != null) {
						l_paraElem.appendChild(l_tokenNode);						
					}

					Element l_posNode = null;
					if(l_outDoc != null) {
						l_posNode = l_outDoc.createElement("Position");
					}					

					if(l_tokenNode != null) {
						l_tokenNode.appendChild(l_posNode);
					}

					if(l_posNode != null) {
						l_posNode.setTextContent(""+l_entry.getKey());
					}

					Element l_tokNode = null;
					if(l_outDoc != null) {
						l_tokNode = l_outDoc.createElement("TokenText");
					}

					if(l_tokenNode != null) {
						l_tokenNode.appendChild(l_tokNode);
					}

					if(l_tokNode != null) {
						l_tokNode.setTextContent(l_entry.getValue());						
					}					
				}
			}
			logger._log("com.opentext.apps.gc.docgen.DocumentGenerator",Severity.INFO,null,"The paragraph("+(lParaText.length()>PARAGRAPH_LIMITTER?(lParaText.substring(0, PARAGRAPH_LIMITTER)+"..."):lParaText)+")"
					+"- tokens replaced"+l_runTokenText+ "- tokens missed"+l_paraTokenText);

		}

	}



	public static String buildDownloadReadPath(String docName, String layoutId) {
		String currentOrgDN = BSF.getOrganization();
		String currentOrgName = currentOrgDN.substring(currentOrgDN.indexOf('=') + 1, currentOrgDN.indexOf(','));

		String relativePath = File.separator + "content" 
				+ File.separator + "docgen"
				+ File.separator + currentOrgName 
				+ File.separator + layoutId;

		File downloadDirectory = new File(EIBProperties.getInstallDir()+relativePath);

		boolean isDownloadLocationExists = downloadDirectory.exists() ? true : downloadDirectory.mkdirs();
		if (isDownloadLocationExists) {
			return relativePath + File.separator + docName + "." + DOCUMENT_TYPE;
		}
		return null;
	} 
	public static int GetValidationInput(String InputLocation)
	{
		Element l_elemNode = GetValidationInputDOM(InputLocation,null);
		if(l_elemNode==null)
		{
			return 0;
		}
		return NomUtil.convertToNom(l_elemNode);
	}
	public static Element GetValidationInputDOM(String InputLocation, DocGenInput iDGInput)
	{
        DocGenInput dgInput = iDGInput;
        
        if(dgInput == null)
        {
        	dgInput = new  DocGenInput();
    		// Fetch details from layout id
         	loadLayoutProperties(InputLocation,dgInput);
        }			
		String SampleInputItemID = dgInput.getSampleInputItemId();
		if(!("".equals(SampleInputItemID) || SampleInputItemID==null))
		{
			String documentStorageTicket = ReadValidationInput(SampleInputItemID);
			if (documentStorageTicket == null)
			{
				logger._log("com.opentext.apps.gc.docgen.DocumentGenerator", Severity.ERROR, null, DocGenAlertMessages.EMPTY_DOCSTORAGETICKET);
				throw new DocGenApplicationException(DocGenAlertMessages.EMPTY_DOCSTORAGETICKET);
			}
			String documentContentStream = downloadLayoutDocument(documentStorageTicket);
			if (documentContentStream == null)
			{
				logger._log("com.opentext.apps.gc.docgen.DocumentGenerator", Severity.ERROR, null, DocGenAlertMessages.EMPTY_DOCCONTENTSTREAM);
				throw new DocGenApplicationException(DocGenAlertMessages.EMPTY_DOCCONTENTSTREAM);
			}
			byte[] docContent = Base64.getDecoder().decode(documentContentStream);
			try
			{
				DocumentBuilderFactory dbf = DocumentBuilderFactory.newInstance();
				dbf.setFeature("http://apache.org/xml/features/disallow-doctype-decl", true);
				DocumentBuilder builder = dbf.newDocumentBuilder();
				org.w3c.dom.Document docc = builder.parse(new ByteArrayInputStream(docContent));
				NodeList mappingNode = docc.getElementsByTagName("GenerateInputXML");
		        return (Element) mappingNode.item(0);
			}
			catch (Exception e) {
				logger._log("com.opentext.apps.gc.docgen.DocumentGenerator", Severity.ERROR, e, "Error while reading validation input.");
				throw new DocGenApplicationException(DocGenAlertMessages.READ_FAILURE_VALIDATION_INPUT);
			}
		}
		else
		{
			String l_inputFilePath = GetValidationInputPath();
			if(l_inputFilePath==null || l_inputFilePath.length()<=0)
			{
				return null;
			}
			File file = new File(GetValidationInputPath());
			DocumentBuilderFactory dbf = DocumentBuilderFactory.newInstance();
			NodeList mappingNode = null;
			org.w3c.dom.Document xml_Document = null;
			try 
			{
				dbf.setFeature("http://apache.org/xml/features/disallow-doctype-decl", true);	//fortify security fix for XXE attacks
				DocumentBuilder db = dbf.newDocumentBuilder();
				xml_Document = db.parse(file);
				mappingNode = xml_Document.getElementsByTagName("GenerateInputXML");
			}
			catch (Exception e) {
				logger._log("com.opentext.apps.gc.docgen.DocumentGenerator", Severity.ERROR, e, "Error while reading validation input.");
				throw new DocGenApplicationException(DocGenAlertMessages.READ_FAILURE_VALIDATION_INPUT);
			}
			return (mappingNode != null ? (Element) mappingNode.item(0) : null);
		}
	}
	
	public static String ReadValidationInput(String ValidationInputItemID)
	{
		Document vallidationDocument= null;
		int ItemID_ValidationInput = 0, response = 0, node_ValidationInput = 0;
        NOMDocumentPool nomDocPool = NOMDocumentPool.getInstance();
        vallidationDocument = nomDocPool.lendDocument();
		try 
		{
			ItemID_ValidationInput = vallidationDocument.createElement("ValidationInput-id");
			Node.createTextElement("ItemId", ValidationInputItemID, ItemID_ValidationInput);
			SOAPRequestObject readValidationInputResponse = new SOAPRequestObject("http://schemas/OpenTextDocumentGeneration/ValidationInput/operations", "ReadValidationInput ", null, null);
			readValidationInputResponse.addParameterAsXml(ItemID_ValidationInput);
			response = readValidationInputResponse.sendAndWait();
			node_ValidationInput = DocGenUtil.getNode(".//ValidationInput", response);
			return Node.getDataWithDefault(DocGenUtil.getNode(".//File/StorageTicket", node_ValidationInput), null);
		}
		catch (Exception e) 
		{
			logger._log("com.opentext.apps.gc.docgen.DocumentGenerator", Severity.ERROR, e, "Error while executing ReadValidationInput Webservice for the ValidationInput ID : "+ValidationInputItemID);
			throw new DocGenApplicationException(DocGenAlertMessages.WEBSERVICE_FAILURE_READ_VALIDATION_INPUT);
		} 
		finally 
		{
			DocGenUtil.cleanAll(node_ValidationInput, response, ItemID_ValidationInput);
			nomDocPool.returnDocument(vallidationDocument);
			vallidationDocument = null;
		}
	}
	public static String GetValidationInputPath()
	{
		String orgDN = BSF.getOrganization();
		String orgName = orgDN.substring(orgDN.indexOf('=') + 1, orgDN.indexOf(','));
		String OrgPath = Paths.get(EIBProperties.getInstallDir()).resolve("webroot"+ File.separator +"organization"+ File.separator +orgName+
				File.separator +"com"+ File.separator +"opentext"+ File.separator +"apps"+ File.separator +"gc"+ File.separator +"docgen"+ File.separator +"samples"+ File.separator +"DefaultSampleInput.xml").toString();
		if(new File(OrgPath).exists())
		{
			return OrgPath;
		}
		else 
		{
			String SharedPath = Paths.get(EIBProperties.getInstallDir()).resolve("webroot"+ File.separator +"shared"+
					File.separator +"com"+ File.separator +"opentext"+ File.separator +"apps"+ File.separator +"gc"+ File.separator +"docgen"+ File.separator +"samples"+ File.separator +"DefaultSampleInput.xml").toString();
			if(new File(SharedPath).exists())
			{
				return SharedPath;
			}
			return "";
		}
	}
	public static int ValidateDocumentLayout(String LayoutId) throws FileNotFoundException, IOException, SAXException, ParserConfigurationException
	{
		DocGenInput dgInput = new DocGenInput();
		// Fetch details from layout id
		loadLayoutProperties(LayoutId,dgInput);	
		
		String documentStorageTicket = dgInput.getStorageTicket();
		if ("".equals(documentStorageTicket) ||documentStorageTicket  == null)
		{
			logger._log("com.opentext.apps.gc.docgen.DocumentGenerator", Severity.ERROR, null, DocGenAlertMessages.EMPTY_DOCSTORAGETICKET);
			throw new DocGenApplicationException(DocGenAlertMessages.EMPTY_DOCSTORAGETICKET);
		}
		// Download document to server
		String documentContentStream = downloadLayoutDocument(documentStorageTicket);
		if (documentContentStream == null)
		{
			logger._log("com.opentext.apps.gc.docgen.DocumentGenerator", Severity.ERROR, null, DocGenAlertMessages.EMPTY_DOCCONTENTSTREAM);
			throw new DocGenApplicationException(DocGenAlertMessages.EMPTY_DOCCONTENTSTREAM);
		}		

		Element validatorElem = docGen(documentContentStream, "ValidatorOutput" , LayoutId.substring(LayoutId.lastIndexOf(".")+1), GetValidationInputDOM(LayoutId,dgInput),true,dgInput);
		if(validatorElem==null)
		{
			return 0;
		}		
		return NomUtil.convertToNom(validatorElem);
	}
	public static String getFileURI(String fileLocation) {
		String fileURI = null;
		File fileLoc = new File(fileLocation);
		if(fileLoc.exists())
		{
			return fileLoc.toURI().toString();
		}
		return fileURI;
	}


	private static void safeClose(FileOutputStream fis) {
		if (fis != null) {
			try {
				fis.close();
			}
			catch (IOException e) {
				logger._log("com.opentext.apps.gc.docgen.DocumentGenerator", Severity.ERROR, e, "Error while releasing file output stream.");
				throw new DocGenApplicationException(DocGenAlertMessages.RELEASE_FILE_OUTPUT_STREAM);
			}
		}
	}

	public static String CorrectLayoutTokens(String LayoutId) throws FileNotFoundException, SAXException, IOException, ParserConfigurationException
	{
		DocGenInput dgInput = new DocGenInput();
		// Fetch details from layout id
		loadLayoutProperties(LayoutId,dgInput);	
		
		String documentStorageTicket = dgInput.getStorageTicket();
		if ("".equals(documentStorageTicket) ||documentStorageTicket  == null)
		{
			logger._log("com.opentext.apps.gc.docgen.DocumentGenerator", Severity.ERROR, null, DocGenAlertMessages.EMPTY_DOCSTORAGETICKET);
			throw new DocGenApplicationException(DocGenAlertMessages.EMPTY_DOCSTORAGETICKET);
		}
		
		// Download document to server
		String documentContentStream = downloadLayoutDocument(documentStorageTicket);
		if (documentContentStream == null)
		{
			logger._log("com.opentext.apps.gc.docgen.DocumentGenerator", Severity.ERROR, null, DocGenAlertMessages.EMPTY_DOCCONTENTSTREAM);
			throw new DocGenApplicationException(DocGenAlertMessages.EMPTY_DOCCONTENTSTREAM);
		}		

		String outputDocumentLocation = CorrectTokens(documentContentStream, "CorrectorOutput" , LayoutId.substring(LayoutId.lastIndexOf(".")+1), GetValidationInputDOM(LayoutId,dgInput),dgInput);		
		
		if (outputDocumentLocation == null)
		{
			logger._log("com.opentext.apps.gc.docgen.DocumentGenerator", Severity.ERROR, null, DocGenAlertMessages.EMPTY_GENERATEDDOCLOCATION);
			throw new DocGenApplicationException(DocGenAlertMessages.EMPTY_GENERATEDDOCLOCATION);
		}
		return outputDocumentLocation;
	}
	
	
	private static String CorrectTokens(String documentContentStream,String DOCUMENT_NAME, String LAYOUT_ID, Element validationXML, DocGenInput dgInput) throws IOException 
	{		
		XWPFDocument document = null;
		String relativeOutputDocLocation = null;
		FileOutputStream outputDocLocation = null;
		try 
		{	
			// Reading document					
			byte[] docContent = Base64.getDecoder().decode(documentContentStream);
			document = new XWPFDocument(new ByteArrayInputStream(docContent));
			String lStartPattern = dgInput.getStartPattern();
			String lEndPattern = dgInput.getEndPattern();
			if(lStartPattern!=null && lEndPattern!=null && !("".equals(lStartPattern)) && !("".equals(lEndPattern)))
			{
				CorrectRelatedParagraphs(document,dgInput);
				if(document.getHeaderFooterPolicy()!=null)
				{
					CorrectRelatedParagraphs(document.getHeaderFooterPolicy().getDefaultHeader(),dgInput);
					CorrectRelatedParagraphs(document.getHeaderFooterPolicy().getFirstPageHeader(),dgInput);
					CorrectRelatedParagraphs(document.getHeaderFooterPolicy().getEvenPageHeader(),dgInput);
					CorrectRelatedParagraphs(document.getHeaderFooterPolicy().getOddPageHeader(),dgInput);
		
					CorrectRelatedParagraphs(document.getHeaderFooterPolicy().getDefaultFooter(),dgInput);
					CorrectRelatedParagraphs(document.getHeaderFooterPolicy().getFirstPageFooter(),dgInput);
					CorrectRelatedParagraphs(document.getHeaderFooterPolicy().getEvenPageFooter(),dgInput);
					CorrectRelatedParagraphs(document.getHeaderFooterPolicy().getOddPageFooter(),dgInput);
				}
			}						
			relativeOutputDocLocation = buildDownloadReadPath(DOCUMENT_NAME, LAYOUT_ID);
			outputDocLocation = new FileOutputStream(EIBProperties.getInstallDir()+relativeOutputDocLocation);
			document.write(outputDocLocation);			
			return relativeOutputDocLocation;
		} 
		catch (Exception e) 
		{
			logger._log("com.opentext.apps.gc.docgen.DocumentGenerator", Severity.ERROR, e, "Error while reading document and correcting tokens.");
		} 
		finally 
		{
			if (outputDocLocation != null) 
			 {
			      safeClose(outputDocLocation);
			 }
			if(document!=null)
			{
				document.close();
			}
		}
		return relativeOutputDocLocation;
	}
	
	private static void CorrectRelatedParagraphs(IBody bodyElem, DocGenInput dgInput) 
	{
		if(bodyElem==null)
		{
			logger._log("com.opentext.apps.gc.docgen.DocumentGenerator",Severity.INFO,null,"Body element is empty");
			return;
		}
		List<XWPFParagraph> lParas = bodyElem.getParagraphs();
		XWPFParagraph[] lParasArray = new XWPFParagraph[lParas.size()];
		Iterator<XWPFParagraph> lparasIterator = lParas.iterator();
		TreeMap<Integer, String> paragraphTokens = new TreeMap<Integer,String>();			
		int iterCount = 0;			
		while(lparasIterator.hasNext())
		{
			lParasArray[iterCount++]=lparasIterator.next();
		}
		for(int indx=0;indx<lParasArray.length;indx++)
		{
			XWPFParagraph paragraph = lParasArray[indx];
			String pText = paragraph.getText();						
			if (pText != null) 
			{					
				paragraphTokens.putAll(getTokensInParagraph(paragraph.getText(),null, dgInput));
				// Proceed if atleast 1 token found in paragraph
				if (paragraphTokens.size() >= 1) 
				{
					List<XWPFRun> runsList = paragraph.getRuns();
					if (runsList != null) 
					{						
						CheckAndCorrectParaTokens(paragraphTokens,runsList,paragraph);
					}						
				}
				paragraphTokens.clear();					
			}
		}			

		for (XWPFTable table : bodyElem.getTables()) 
		{
			for (XWPFTableRow rows : table.getRows()) 
			{
				for (XWPFTableCell cells : rows.getTableCells()) 
				{
					for (XWPFParagraph cellParagraph : cells.getParagraphs()) 
					{
						if(cellParagraph.getText() != null) 
						{							
							paragraphTokens.putAll(getTokensInParagraph(cellParagraph.getText(),null, dgInput));								
							// Proceed if atleast 1 token found in paragraph
							if (paragraphTokens.size() >= 1) 
							{
								List<XWPFRun> runsList = cellParagraph.getRuns();
								if (runsList != null) 
								{						
									CheckAndCorrectParaTokens(paragraphTokens,runsList,cellParagraph);
								}						
							}
							paragraphTokens.clear();
						}						
					}
				}
			}
		}
	}
	
	private static HashMap<Integer, String> getTokensInParagraph(String text,Set<String> tokenKeys, DocGenInput dgInput) 
	{		
		HashMap<Integer, String> TOKEN_FOUND = new HashMap<Integer, String>();
		String START_PATTERN = dgInput.getStartPattern();
		String END_PATTERN = dgInput.getEndPattern();
		int l_foundStartIndex = text.indexOf(START_PATTERN);		
		while(l_foundStartIndex>=0)
		{
			int l_foundEndIndex = text.indexOf(END_PATTERN, l_foundStartIndex+START_PATTERN.length());
			int l_nextIndex = text.indexOf(START_PATTERN, l_foundStartIndex+START_PATTERN.length());
			if(l_foundEndIndex<0)
			{
				break;
			}
			if(l_nextIndex<0 || l_nextIndex>l_foundEndIndex)
			{
				String tokenText = text.substring(l_foundStartIndex, l_foundEndIndex)+END_PATTERN;
				if(tokenKeys == null)
				{					
					TOKEN_FOUND.put(l_foundStartIndex, tokenText);
				}
				else if(tokenKeys.contains(tokenText))				
				{
					TOKEN_FOUND.put(l_foundStartIndex, tokenText);
				}
			}
			l_foundStartIndex = l_nextIndex;
		}		
		return TOKEN_FOUND;
	}

	private static void CheckAndCorrectParaTokens(TreeMap<Integer, String> paragraphTokens, List<XWPFRun> runsList, XWPFParagraph iPara) 
	{
		ArrayList<Integer> removableRuns = new ArrayList<Integer>();
		Set<Integer> sortedKeys = paragraphTokens.keySet();		
		Iterator<Integer> tknItr = sortedKeys.iterator();
		Boolean tokensCompleted = tknItr.hasNext()?false:true;
		int accumLength = 0;		
		int currentTargetStart = tknItr.next();
		int currentTargetEnd = currentTargetStart+(paragraphTokens.get(currentTargetStart).length())-1;
		for(int indx=0;indx<runsList.size();indx++)
		{
			XWPFRun lRun = runsList.get(indx);			
			String lRunText = lRun.getText(0);
			int lrunStart = accumLength;			
			accumLength+= lRun.text().length();
			int lRunEnd = (accumLength)-1;
			if(lRunText==null || lRunText.length()==0 || tokensCompleted)
			{				
				continue;
			}
			
			if(currentTargetStart>=lrunStart)
			{
				if(currentTargetStart>lRunEnd)
				{
					continue;
				}
				if(currentTargetEnd==lRunEnd)
				{					
					if(tknItr.hasNext())
					{
						currentTargetStart = tknItr.next();
						currentTargetEnd = currentTargetStart+(paragraphTokens.get(currentTargetStart).length())-1;
					}
					else
					{
						tokensCompleted=true;
					}
				}
				else if(currentTargetEnd<lRunEnd)
				{					
					while(currentTargetEnd<lRunEnd && (tknItr.hasNext()))
					{						
						currentTargetStart = tknItr.next();
						currentTargetEnd = currentTargetStart+(paragraphTokens.get(currentTargetStart).length())-1;
					}
					if(currentTargetEnd<=lRunEnd)
					{						
						tokensCompleted=true;
					}					
					else if(currentTargetStart<=lRunEnd)
					{						
						SetTextOfTheRun(lRun,lRunText.substring(0, currentTargetStart-lrunStart),0);
					}
				}
				else if(currentTargetStart==lrunStart)
				{
					removableRuns.add(indx);
					continue;
				}
				else if ((currentTargetStart-lrunStart)>0 )
				{					
					SetTextOfTheRun(lRun,lRunText.substring(0, currentTargetStart-lrunStart),0);
				}
			}
			else if(currentTargetStart<lrunStart)
			{
				if(currentTargetEnd>lRunEnd)
				{
					removableRuns.add(indx);
					continue;
				}
				if(currentTargetEnd==lRunEnd)
				{					
					SetTextOfTheRun(lRun,paragraphTokens.get(currentTargetStart),0);
					if(tknItr.hasNext())
					{
						currentTargetStart = tknItr.next();
						currentTargetEnd = currentTargetStart+(paragraphTokens.get(currentTargetStart).length())-1;
					}
					else
					{
						tokensCompleted=true;						
					}
				}
				else if(currentTargetEnd<lRunEnd)
				{					
					int l_currentStart = currentTargetStart;
					int l_currentEnd = currentTargetEnd;
					while(currentTargetEnd<lRunEnd && (tknItr.hasNext()))
					{						
						currentTargetStart = tknItr.next();
						currentTargetEnd = currentTargetStart+(paragraphTokens.get(currentTargetStart).length())-1;
					}
					if(l_currentEnd==currentTargetEnd || currentTargetStart>lRunEnd || currentTargetEnd<=lRunEnd)
					{						
						SetTextOfTheRun(lRun,paragraphTokens.get(l_currentStart).concat(lRunText.substring(l_currentEnd-lrunStart+1)) ,0);
						tokensCompleted=currentTargetStart>lRunEnd?false:true;
					}
					else if(currentTargetStart<lRunEnd && currentTargetEnd>lRunEnd)
					{
						SetTextOfTheRun(lRun,paragraphTokens.get(l_currentStart).concat(lRunText.substring(l_currentEnd-lrunStart+1,currentTargetStart-lrunStart)),0);						
					}
					else
					{
						SetTextOfTheRun(lRun,paragraphTokens.get(l_currentStart),0);
					}
				}
			}			 
		}
		int rmvRunSize = removableRuns.size();		
		for(int rmvi =rmvRunSize; rmvi>0;rmvi--)
		{
			iPara.removeRun(removableRuns.get(rmvi-1));			
		}
	}

	public void onInsert() {
	}

	public void onUpdate() {
	}

	public void onDelete() {
	}

}
